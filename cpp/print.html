<!DOCTYPE HTML>
<html lang="jp" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>nlptr-lib (lib/cpp/)</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="setup.html">setup</a></li><li class="chapter-item expanded affix "><li class="part-title">lib/cpp/</li><li class="chapter-item expanded "><a href="algebra.html"><strong aria-hidden="true">1.</strong> algebra</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algebra/chinese-remainder-theorem.html"><strong aria-hidden="true">1.1.</strong> Chinese Remainder Theorem (ä¸­å›½å‰°ä½™å®šç†)</a></li><li class="chapter-item expanded "><a href="algebra/factorial.html"><strong aria-hidden="true">1.2.</strong> Factorial (éšä¹—ã€çµ„ã¿åˆã‚ã›)</a></li><li class="chapter-item expanded "><a href="algebra/formal-power-series.html"><strong aria-hidden="true">1.3.</strong> Formal Power Series (å½¢å¼çš„å†ªç´šæ•°)</a></li><li class="chapter-item expanded "><a href="algebra/golden-section-search.html"><strong aria-hidden="true">1.4.</strong> Golden Section Search (é»„é‡‘åˆ†å‰²æ¢ç´¢)</a></li><li class="chapter-item expanded "><a href="algebra/lagrange-interpolation.html"><strong aria-hidden="true">1.5.</strong> Lagrange Interpolation (ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥å¤šé …å¼è£œé–“)</a></li><li class="chapter-item expanded "><a href="algebra/linear-sieve.html"><strong aria-hidden="true">1.6.</strong> Linear Sieve (ç·šå½¢ç¯©ã€æ·»ãˆå­— gcd ç•³ã¿è¾¼ã¿)</a></li><li class="chapter-item expanded "><a href="algebra/modular.html"><strong aria-hidden="true">1.7.</strong> Modular (å‰°ä½™ç’°ä¸Šã®å‹)</a></li><li class="chapter-item expanded "><a href="algebra/rational.html"><strong aria-hidden="true">1.8.</strong> Rational (æœ‰ç†æ•°å‹)</a></li><li class="chapter-item expanded "><a href="algebra/slide.html"><strong aria-hidden="true">1.9.</strong> Slide (ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤ãƒ»æœ€å¤§å€¤)</a></li><li class="chapter-item expanded "><a href="algebra/square-matrix.html"><strong aria-hidden="true">1.10.</strong> Square Matrix (æ­£æ–¹è¡Œåˆ—ã®ç´¯ä¹—)</a></li></ol></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">2.</strong> conv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conv/fast-fourier-transform.html"><strong aria-hidden="true">2.1.</strong> Fast Fourier Transform (FFTã€é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›)</a></li><li class="chapter-item expanded "><a href="conv/number-theoretic-transform.html"><strong aria-hidden="true">2.2.</strong> Number Theoretic Transform (NTTã€æ•°è«–å¤‰æ›)</a></li></ol></li><li class="chapter-item expanded "><a href="data-structures.html"><strong aria-hidden="true">3.</strong> data-structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-structures/binary-indexed-tree.html"><strong aria-hidden="true">3.1.</strong> Binary Indexed Tree (BIT)</a></li><li class="chapter-item expanded "><a href="data-structures/convex-hull-trick.html"><strong aria-hidden="true">3.2.</strong> Convex Hull Trick</a></li><li class="chapter-item expanded "><a href="data-structures/cumulative-sum-2d.html"><strong aria-hidden="true">3.3.</strong> Cumulative Sum 2d (äºŒæ¬¡å…ƒç´¯ç©å’Œ)</a></li><li class="chapter-item expanded "><a href="data-structures/swag.html"><strong aria-hidden="true">3.4.</strong> SWAG (Sliding Window Aggregation)</a></li><li class="chapter-item expanded "><a href="data-structures/segment-tree.html"><strong aria-hidden="true">3.5.</strong> Segment Tree (é…å»¶è©•ä¾¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨)</a></li><li class="chapter-item expanded "><a href="data-structures/slope-trick.html"><strong aria-hidden="true">3.6.</strong> Slope Trick</a></li><li class="chapter-item expanded "><a href="data-structures/sparse-table.html"><strong aria-hidden="true">3.7.</strong> Sparse Table</a></li><li class="chapter-item expanded "><a href="data-structures/union-find.html"><strong aria-hidden="true">3.8.</strong> Union Find</a></li><li class="chapter-item expanded "><a href="data-structures/weighted-union-find.html"><strong aria-hidden="true">3.9.</strong> Weighted Union Find</a></li><li class="chapter-item expanded "><a href="data-structures/zip.html"><strong aria-hidden="true">3.10.</strong> Zip (åº§åœ§)</a></li></ol></li><li class="chapter-item expanded "><a href="dp.html"><strong aria-hidden="true">4.</strong> dp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dp/traveling-salesman-problem.html"><strong aria-hidden="true">4.1.</strong> Traveling Salesman Problem (å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œ)</a></li></ol></li><li class="chapter-item expanded "><a href="geo.html"><strong aria-hidden="true">5.</strong> geo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geo/vec2.html"><strong aria-hidden="true">5.1.</strong> Vec2 (å¹¾ä½•)</a></li></ol></li><li class="chapter-item expanded "><a href="graphs.html"><strong aria-hidden="true">6.</strong> graphs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphs/bellman-ford.html"><strong aria-hidden="true">6.1.</strong> Bellman Ford</a></li><li class="chapter-item expanded "><a href="graphs/dijkstra.html"><strong aria-hidden="true">6.2.</strong> Dijkstra</a></li><li class="chapter-item expanded "><a href="graphs/dinic.html"><strong aria-hidden="true">6.3.</strong> Dinic (æœ€å¤§æµ)</a></li><li class="chapter-item expanded "><a href="graphs/kruskal.html"><strong aria-hidden="true">6.4.</strong> Kruskal</a></li><li class="chapter-item expanded "><a href="graphs/prim.html"><strong aria-hidden="true">6.5.</strong> Prim</a></li><li class="chapter-item expanded "><a href="graphs/topological-sort.html"><strong aria-hidden="true">6.6.</strong> Topological Sort</a></li></ol></li><li class="chapter-item expanded "><a href="others.html"><strong aria-hidden="true">7.</strong> others</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="others/fast-iostream.html"><strong aria-hidden="true">7.1.</strong> Fast IOStream</a></li><li class="chapter-item expanded "><a href="others/policy-based-data-structures.html"><strong aria-hidden="true">7.2.</strong> Policy Based Data Structures (g++ æ‹¡å¼µ)</a></li><li class="chapter-item expanded "><a href="others/debug.html"><strong aria-hidden="true">7.3.</strong> debug.hpp</a></li></ol></li><li class="chapter-item expanded "><a href="strings.html"><strong aria-hidden="true">8.</strong> strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="strings/manacher.html"><strong aria-hidden="true">8.1.</strong> Manacher</a></li><li class="chapter-item expanded "><a href="strings/morris-pratt.html"><strong aria-hidden="true">8.2.</strong> Morris Pratt (MP æ³•)</a></li><li class="chapter-item expanded "><a href="strings/rolling-hash.html"><strong aria-hidden="true">8.3.</strong> Rolling Hash</a></li><li class="chapter-item expanded "><a href="strings/sa-is.html"><strong aria-hidden="true">8.4.</strong> SA-IS (Suffix Array)</a></li><li class="chapter-item expanded "><a href="strings/trie.html"><strong aria-hidden="true">8.5.</strong> Trie (ãƒˆãƒ©ã‚¤æœ¨)</a></li><li class="chapter-item expanded "><a href="strings/z-algorithm.html"><strong aria-hidden="true">8.6.</strong> Z Algorithm (æœ€é•·å…±é€šæ¥é ­è¾)</a></li></ol></li><li class="chapter-item expanded "><a href="trees.html"><strong aria-hidden="true">9.</strong> trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="trees/diameter.html"><strong aria-hidden="true">9.1.</strong> Diameter (æœ¨ã®ç›´å¾„)</a></li><li class="chapter-item expanded "><a href="trees/rerooting-edge.html"><strong aria-hidden="true">9.2.</strong> Rerooting[op_edge] (å…¨æ–¹ä½æœ¨ dp)</a></li><li class="chapter-item expanded "><a href="trees/rerooting-node.html"><strong aria-hidden="true">9.3.</strong> Rerooting[op_node] (å…¨æ–¹ä½æœ¨ dp)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nlptr-lib (lib/cpp/)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/nullputra/nlptr-lib" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-nlptr-lib"><a class="header" href="#-nlptr-lib">â›„ nlptr-lib</a></h1>
<p><a href="https://nullputra.github.io/nlptr-lib/"><img src="https://img.shields.io/static/v1?label=GitHub+Pages&amp;message=+&amp;color=brightgreen&amp;logo=github" alt="gh-pages" /></a>
<a href="https://github.com/nullputra/nlptr-lib/actions/workflows/verify.yml"><img src="https://github.com/nullputra/nlptr-lib/actions/workflows/verify.yml/badge.svg" alt="verify" /></a>
<a href="https://github.com/nullputra/nlptr-lib/commits/master"><img src="https://img.shields.io/github/last-commit/nullputra/nlptr-lib" alt="last-commit" /></a>
<a href="https://github.com/nullputra/nlptr-lib/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-CC0--1.0-blue" alt="license" /></a>
<a href="https://atcoder.jp/users/nlptr"><img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fatcoder-badges.now.sh%2Fapi%2Fatcoder%2Fjson%2Fnlptr" alt="atcoder" /></a></p>
<p>C++17 / C# .NET Core 3.1 / Rust 1.59 ã®ç«¶ãƒ—ãƒ­ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚ãƒã‚°å ±å‘Šã¯ <a href="https://github.com/nullputra/nlptr-lib/issues">Issues</a> ã‹ <a href="https://github.com/nullputra/nlptr-lib/pulls">Pull requests</a> ã¸ã©ã†ãã€‚</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>ã»ã¨ã‚“ã©ã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯ <a href="https://creativecommons.org/publicdomain/zero/1.0/deed.ja">CC0-1.0</a> ã§ã™ (ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè¡¨è¨˜ä¸è¦)ã€‚<a href="https://creativecommons.org/publicdomain/zero/1.0/deed.ja">CC0-1.0</a> ä»¥å¤–ã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã«ãã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://nullputra.github.io/nlptr-lib">lib/</a></li>
<li><a href="https://nullputra.github.io/nlptr-lib/cpp">lib/cpp/</a></li>
<li><a href="https://nullputra.github.io/nlptr-lib/CSharp">lib/CSharp/</a></li>
<li><a href="https://nullputra.github.io/nlptr-lib/rust">lib/rust/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-c-ã®ç’°å¢ƒæ§‹ç¯‰"><a class="header" href="#-c-ã®ç’°å¢ƒæ§‹ç¯‰">ğŸ‡ C++ ã®ç’°å¢ƒæ§‹ç¯‰</a></h1>
<h2 id="1-wsl-build-essential-ã‚’å…¥ã‚Œã¾ã™"><a class="header" href="#1-wsl-build-essential-ã‚’å…¥ã‚Œã¾ã™">1. WSL, build-essential ã‚’å…¥ã‚Œã¾ã™</a></h2>
<ul>
<li>å‚è€ƒ: <a href="https://nullputra.github.io/nlptr-lib/set-up-wsl.html">lib/set-up-wsl</a></li>
</ul>
<h2 id="2-oj-bundle-ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«"><a class="header" href="#2-oj-bundle-ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«">2. <code>oj-bundle</code> ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«</a></h2>
<p>ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå±•é–‹ã‚³ãƒãƒ³ãƒ‰ <code>oj-bundle</code> ã¯ã€<code>online-judge-verify-helper</code> (åˆ¥å <a href="https://github.com/online-judge-tools/verification-helper">verification-helper</a>) ã®ä¸­ã«å…¥ã£ã¦ã„ã¾ã™ã€‚</p>
<p>ã¾ãš <code>python3</code>ã€<code>pip3</code> ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã‹ã‚‰ã€<code>online-judge-verify-helper</code> ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚</p>
<pre><code class="language-sh">sudo apt install python3

# pip / pip3 ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«ã¯ universe ãƒ¬ãƒã‚¸ãƒˆãƒªã‚’æ¤œç´¢å¯¾è±¡ã«å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹
apt -y install software-properties-common
add-apt-repository universe

# pip / pip3 ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
apt install python3-pip

# online-judge-verify-helper ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip3 install online-judge-verify-helper
</code></pre>
<h2 id="3-å®Ÿéš›ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•"><a class="header" href="#3-å®Ÿéš›ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•">3. å®Ÿéš›ã«ãƒãƒ³ãƒ‰ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•</a></h2>
<p><code>oj-bundle</code> ã§ãƒãƒ³ãƒ‰ãƒ«ã•ã‚Œã‚‹æ§˜å­ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>
<h4 id="ç”¨æ„ã™ã‚‹ã‚‚ã®-1-srcmaincpp"><a class="header" href="#ç”¨æ„ã™ã‚‹ã‚‚ã®-1-srcmaincpp">ç”¨æ„ã™ã‚‹ã‚‚ã® (1): src/main.cpp</a></h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define PROBLEM &quot;https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_12_A&quot;
#include &quot;graphs/prim.hpp&quot;
// ç’°å¢ƒè¨­å®šã«ã‚ˆã£ã¦ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ãªã„ã¨ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹
// #include &quot;../lib/cpp/graphs/prim.hpp&quot;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt;&gt; adja(n, vector&lt;int&gt;(n));
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            cin &gt;&gt; adja[i][j];
        }
    }
    Prim pr(adja);
    cout &lt;&lt; pr.cost_tot &lt;&lt; '\n';
}
</code></pre>
<h4 id="ç”¨æ„ã™ã‚‹ã‚‚ã®-2-libcppgraphsprimhpp"><a class="header" href="#ç”¨æ„ã™ã‚‹ã‚‚ã®-2-libcppgraphsprimhpp">ç”¨æ„ã™ã‚‹ã‚‚ã® (2): lib/cpp/graphs/prim.hpp</a></h4>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Prim {
    T cost_tot = 0;
    static constexpr T TINF = numeric_limits&lt;T&gt;::max();
    Prim(vector&lt;vector&lt;T&gt;&gt; &amp;adja) {
        int n = adja.size();
        vector&lt;T&gt; min_cost(n, TINF);
        min_cost[0] = 0;
        vector&lt;bool&gt; vis(n);
        while (true) {
            int from = -1;
            for (int u = 0; u &lt; n; u++) {
                if (!vis[u] &amp;&amp; (from == -1 || min_cost[u] &lt; min_cost[from])) from = u;
            }
            if (from == -1) break;
            vis[from] = true;
            cost_tot += min_cost[from];
            for (int to = 0; to &lt; n; to++) {
                if (adja[from][to] != -1) min_cost[to] = min(min_cost[to], adja[from][to]);
            }
        }
    }
};
</code></pre>
<p>ä»¥ä¸Šã‚’ç”¨æ„ã—ã¦ã€ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</p>
<h4 id="ã‚¿ãƒ¼ãƒŸãƒŠãƒ«"><a class="header" href="#ã‚¿ãƒ¼ãƒŸãƒŠãƒ«">ã‚¿ãƒ¼ãƒŸãƒŠãƒ«</a></h4>
<pre><code class="language-sh">oj-bundle -I./lib/cpp src/main.cpp | sed '/PROBLEM/d' | sed '/line/d' &gt; src/main-bundled.cpp
</code></pre>
<h4 id="ç”Ÿæˆã•ã‚Œã‚‹ã‚‚ã®-srcmain-bundledcpp"><a class="header" href="#ç”Ÿæˆã•ã‚Œã‚‹ã‚‚ã®-srcmain-bundledcpp">ç”Ÿæˆã•ã‚Œã‚‹ã‚‚ã®: src/main-bundled.cpp</a></h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

template &lt;class T&gt;
struct Prim {
    T cost_tot = 0;
    static constexpr T TINF = numeric_limits&lt;T&gt;::max();
    Prim(vector&lt;vector&lt;T&gt;&gt; &amp;adja) {
        int n = adja.size();
        vector&lt;T&gt; min_cost(n, TINF);
        min_cost[0] = 0;
        vector&lt;bool&gt; vis(n);
        while (true) {
            int from = -1;
            for (int u = 0; u &lt; n; u++) {
                if (!vis[u] &amp;&amp; (from == -1 || min_cost[u] &lt; min_cost[from])) from = u;
            }
            if (from == -1) break;
            vis[from] = true;
            cost_tot += min_cost[from];
            for (int to = 0; to &lt; n; to++) {
                if (adja[from][to] != -1) min_cost[to] = min(min_cost[to], adja[from][to]);
            }
        }
    }
};

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt;&gt; adja(n, vector&lt;int&gt;(n));
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            cin &gt;&gt; adja[i][j];
        }
    }
    Prim pr(adja);
    cout &lt;&lt; pr.cost_tot &lt;&lt; '\n';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/algebra">lib/cpp/algebra</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chinese-remainder-theorem-ä¸­å›½å‰°ä½™å®šç†"><a class="header" href="#chinese-remainder-theorem-ä¸­å›½å‰°ä½™å®šç†">Chinese Remainder Theorem (ä¸­å›½å‰°ä½™å®šç†)</a></h1>
<ul>
<li>
<p><code>ext_gcd(a, b, x, y)</code>: æ‹¡å¼µãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ã®äº’é™¤æ³•ã€‚</p>
</li>
<li>
<p><code>crt_2d(b1, m1, b2, m2)</code>: 2 æ¬¡ã®ä¸­å›½å‰°ä½™å®šç†ã€‚</p>
</li>
<li>
<p><code>crt(b, m)</code>: n æ¬¡ã®ä¸­å›½å‰°ä½™å®šç†ã€‚</p>
</li>
<li>
<p><a href="https://qiita.com/drken/items/ae02240cd1f8edfc86fd">ä¸­å›½å‰°ä½™å®šç† (CRT) ã®è§£èª¬ã¨ã€ãã‚Œã‚’ç”¨ã„ã‚‹å•é¡Œã®ã¾ã¨ã‚</a>, drken</p>
</li>
</ul>
<h2 id="impl"><a class="header" href="#impl">Impl</a></h2>
<pre><code class="language-cpp">namespace chinese_remainder_theorem {
using ll = long long;
constexpr pair&lt;ll, ll&gt; no_sol = {0, -1};
ll mod(ll x, ll y) { return x %= y, x &lt; 0 ? x + y : x; }
ll ext_gcd(ll a, ll b, ll &amp;x, ll &amp;y) {
    if (!b) return x = 1, y = 0, a;
    ll g = ext_gcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
pair&lt;ll, ll&gt; crt_2d(ll b1, ll m1, ll b2, ll m2) {
    ll p, q, g = ext_gcd(m1, m2, p, q);
    if ((b2 - b1) % g) return no_sol;
    ll lcm_m = m1 * (m2 / g);
    ll mul = (b2 - b1) / g * p % (m2 / g);
    ll r = mod(b1 + m1 * mul, lcm_m);
    return {r, lcm_m};
}
pair&lt;ll, ll&gt; crt(vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;m) {
    assert(b.size() == m.size());
    ll r = 0, lcm_m = 1;
    for (int i = 0; i &lt; (int)b.size(); i++) {
        ll p, q, g = ext_gcd(lcm_m, m[i], p, q);
        if ((b[i] - r) % g) return no_sol;
        ll mul = (b[i] - r) / g * p % (m[i] / g);
        r += lcm_m * mul;
        lcm_m *= m[i] / g;
    }
    return {mod(r, lcm_m), lcm_m};
}
}  // namespace chinese_remainder_theorem
using namespace chinese_remainder_theorem;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial-éšä¹—çµ„ã¿åˆã‚ã›"><a class="header" href="#factorial-éšä¹—çµ„ã¿åˆã‚ã›">Factorial (éšä¹—ã€çµ„ã¿åˆã‚ã›)</a></h1>
<p>éšä¹—ç³»åˆ—ã®é–¢æ•°ã€‚éšä¹—ãªã©ã®é…åˆ—ã®ç”¨æ„ã™ã¹ãã‚µã‚¤ã‚ºã®æŒ‡å®šãŒä¸è¦ã§ã€å¿…è¦ã«å¿œã˜è‡ªå‹•ã§å¢—ç¯‰ã•ã‚Œã¾ã™ã€‚</p>
<ul>
<li>
<p><code>fact(n)</code>: \(n!\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>inv_fact(n)</code>: \(\frac{1}{n!}\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>comb(n, r)</code>: \(_nC_r\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>perm(n, r)</code>: \(_nP_r\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>homo(n, r)</code>: \(_nH_r\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>catalan(n)</code>: ã‚«ã‚¿ãƒ©ãƒ³æ•° \(c_n = \frac{_{2n}C_n}{n+1}\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)<br>
e.g. \(n=0,1,2, ...\) ã«å¯¾ã—ã¦ \(c_n\) ã¯ \(1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, \cdots\) ã¨ãªã‚‹ã€‚</p>
<ul>
<li>ã‚«ã‚¿ãƒ©ãƒ³æ•°ã®è¡¨ç¾ã€‚
<ol>
<li>æ¼¸åŒ–å¼ \(c_0 = 1, c_{n+1} = \sum_{i=0}^{n} c_i c_{n-i}\) ã‚’æº€ãŸã™æ•°åˆ— \(c_n\)</li>
<li>ç¸¦æ¨ª \(n\) ãƒã‚¹ã®æ ¼å­ã«ãŠã„ã¦å·¦ä¸‹ã‹ã‚‰å³ä¸Šã¾ã§å¯¾è§’ç·šã‚’ã¾ãŸãŒãšã«è¡Œãï¼ˆè¸ã‚€ã®ã¯ okï¼‰æœ€çŸ­çµŒè·¯ã®æ•° \(c_n\)</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>inv(n, r)</code>: \(\frac{1}{n}\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</p>
</li>
<li>
<p><code>0_M</code> ã§ <code>mint(0)</code> ã‚’è¡¨ç¾ã§ãã¾ã™ (<code>std::accumulate</code> ã®ç¬¬ä¸‰å¼•æ•°ãªã©ã§ä½¿ã†)ã€‚</p>
</li>
</ul>
<h2 id="refs"><a class="header" href="#refs">Refs</a></h2>
<ul>
<li><a href="https://github.com/yosupo06/yosupo-library/blob/master/yosupo/comb.hpp">https://github.com/yosupo06/yosupo-library/blob/master/yosupo/comb.hpp</a>, yosupo</li>
<li><a href="https://github.com/tatyam-prime/kyopro_library/blob/master/Modint.cpp">https://github.com/tatyam-prime/kyopro_library/blob/master/Modint.cpp</a>, tatyam</li>
<li><a href="https://manabitimes.jp/math/657">ã‚«ã‚¿ãƒ©ãƒ³æ•°ã®æ„å‘³ã¨æ¼¸åŒ–å¼ - é«˜æ ¡æ•°å­¦ã®ç¾ã—ã„ç‰©èª</a>, ãƒã‚¹ã‚ª</li>
</ul>
<h2 id="impl-1"><a class="header" href="#impl-1">Impl</a></h2>
<pre><code class="language-cpp">#ifndef FACTORIAL_HPP
#define FACTORIAL_HPP

#include &quot;algebra/modular.hpp&quot;

struct Factorial {
    int fact_size = 1, inv_size = 2;
    vector&lt;mint&gt; fact{1}, inv_fact{1}, inv{0, 1};
    void expand_fact(int mx) {
        while (fact_size &lt;= mx) {
            fact.resize(2 * fact_size);
            inv_fact.resize(2 * fact_size);
            for (int i = fact_size; i &lt; 2 * fact_size; i++) fact[i] = fact[i - 1] * i;
            inv_fact[2 * fact_size - 1] = fact[2 * fact_size - 1].inv();
            for (int i = 2 * fact_size - 1; i &gt;= fact_size + 1; i--) inv_fact[i - 1] = inv_fact[i] * i;
            fact_size *= 2;
        }
    }
    void expand_inv(int mx) {
        while (inv_size &lt;= mx) {
            inv.resize(2 * inv_size);
            for (int i = inv_size; i &lt; 2 * inv_size; i++) {
                inv[i] = (mint::mod() - mint::mod() / i) * inv[mint::mod() % i];
            }
            inv_size *= 2;
        }
    }
} _ft;
mint fact(int n) {
    assert(n &gt;= 0);
    internal::_ft.expand_fact(n);
    return internal::_ft.fact[n];
}
mint inv_fact(int n) {
    assert(n &gt;= 0);
    internal::_ft.expand_fact(n);
    return internal::_ft.inv_fact[n];
}
mint comb(int n, int r) {
    assert(n &gt;= 0 &amp;&amp; r &gt;= 0);
    return n &lt; r ? 0 : fact(n) * inv_fact(r) * inv_fact(n - r);
}
mint perm(int n, int r) {
    assert(n &gt;= 0 &amp;&amp; r &gt;= 0);
    return n &lt; r ? 0 : fact(n) * inv_fact(n - r);
}
mint homo(int n, int r) {
    return comb(n + r - 1, r);
}
mint catalan(int n) {
    return fact(n * 2) * inv_fact(n) * inv_fact(n + 1);
}
mint inv(int n) {
    assert(n &gt; 0);
    internal::_ft.expand_inv(n);
    return internal::_ft.inv[n];
}

#endif  // FACTORIAL_HPP
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formal-power-series-å½¢å¼çš„å†ªç´šæ•°"><a class="header" href="#formal-power-series-å½¢å¼çš„å†ªç´šæ•°">Formal Power Series (å½¢å¼çš„å†ªç´šæ•°)</a></h1>
<ul>
<li>constructor <code>FPS(v)</code>: <code>v</code> ã§åˆæœŸåŒ–ã€‚</li>
<li>constructor <code>FPS(list)</code>: <code>list</code> ã§åˆæœŸåŒ–ã€‚</li>
<li><code>integral()</code>: \(\int f(x)\) ã‚’è¿”ã™ (è¡¨ã—ã¦ã„ã‚‹é–¢æ•°ã‚’ \(f\) ã¨ã—ãŸ)ã€‚</li>
<li><code>eval(x)</code>: \(f(x)\) ã‚’è¿”ã™ã€‚</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-cpp">const int MOD = 1e9 + 7;
#include &quot;algebra/formal-power-series.hpp&quot;
vector&lt;mint&gt; a(n, 2);
FPS f(a);
f *= FPS{2};
</code></pre>
<h2 id="refs-1"><a class="header" href="#refs-1">Refs</a></h2>
<ul>
<li><a href="https://github.com/yosupo06/yosupo-library/blob/master/yosupo/fps.hpp">https://github.com/yosupo06/yosupo-library/blob/master/yosupo/fps.hpp</a>, yosupo</li>
<li>(<a href="https://opt-cp.com/fps-fast-algorithms/">å½¢å¼çš„å†ªç´šæ•°ï¼ˆFPSï¼‰ã® invï¼Œlogï¼Œexpï¼Œpow ã®å®šæ•°å€ã®è»½ã„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, opt)</li>
</ul>
<h2 id="impl-2"><a class="header" href="#impl-2">Impl</a></h2>
<pre><code class="language-cpp">#include &quot;conv/number-theoretic-transform.hpp&quot;

template &lt;class T&gt;
struct FormalPowerSeries : public vector&lt;T&gt; {
   public:
    using vector&lt;T&gt;::operator=;
    using FPS = FormalPowerSeries;
    FormalPowerSeries() {}
    FormalPowerSeries(vector&lt;T&gt; &amp;v) : vector&lt;T&gt;(v) { shrink(); }
    FormalPowerSeries(initializer_list&lt;T&gt; list) : vector&lt;T&gt;(list) { shrink(); }
    FPS &amp;operator+=(const FPS &amp;rhs) {
        if (size() &lt; rhs.size()) this-&gt;resize(rhs.size());
        for (int i = 0; i &lt; rhs.size(); i++) (*this)[i] += rhs.freq(i);
        return shrink();
    }
    FPS &amp;operator-=(const FPS &amp;rhs) {
        if (size() &lt; rhs.size()) this-&gt;resize(rhs.size());
        for (int i = 0; i &lt; rhs.size(); i++) (*this)[i] -= rhs[i];
        return shrink();
    }
    FPS &amp;operator*=(const FPS &amp;rhs) {
        *this = NTT.conv(*this, rhs);
        return shrink();
    }
    FPS &amp;operator*=(const T &amp;r) {
        for (int i = 0; i &lt; size(); i++) (*this)[i] *= r;
        return shrink();
    }
    FPS &amp;operator&lt;&lt;=(int s) {
        this-&gt;insert(this-&gt;begin(), s, T(0));
        return shrink();
    }
    FPS &amp;operator&gt;&gt;=(int s) {
        if (size() &lt;= s) return FPS();
        this-&gt;erase(this-&gt;begin(), this-&gt;begin() + s);
        return shrink();
    }
    mint &amp;operator[](int p) {
        if (size() &lt; p) this-&gt;resize(p + 1);
        return vector&lt;T&gt;::operator[](p);
    }
    friend FPS operator+(const FPS &amp;lhs, const FPS &amp;rhs) { return FPS(lhs) += rhs; }
    friend FPS operator-(const FPS &amp;lhs, const FPS &amp;rhs) { return FPS(lhs) -= rhs; }
    friend FPS operator*(const FPS &amp;lhs, const FPS &amp;rhs) { return FPS(lhs) *= rhs; }
    friend FPS operator&lt;&lt;(const FPS &amp;lhs, const int s) { return FPS(lhs) &lt;&lt;= s; }
    friend FPS operator&gt;&gt;(const FPS &amp;lhs, const int s) { return FPS(lhs) &gt;&gt;= s; }
    FPS integral() const {
        vector&lt;T&gt; res(size() + 1);
        for (int i = 0; i &lt; size(); i++) res[i + 1] = (*this)[i] / (i + 1);
        return res;
    }
    T eval(T x) const {
        T sum = 0, base = 1;
        for (int i = 0; i &lt; size(); i++) sum += base * (*this)[i], base *= x;
        return sum;
    }
    int size() const { return vector&lt;T&gt;::size(); }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const FPS &amp;pol) {
#ifdef _DEBUG
        if (!pol.size()) return os &lt;&lt; '0';
        for (int i = 0; i &lt; pol.size(); i++) {
            if (pol[i].val()) {
                os &lt;&lt; pol[i].val() &lt;&lt; &quot;x^&quot; &lt;&lt; i;
                if (i != pol.size() - 1) os &lt;&lt; '+';
            }
        }
#endif
        return os;
    }

   private:
    T freq(int p) const {
        return size() &lt; p ? 0 : vector&lt;T&gt;::operator[](p);
    }
    FPS &amp;shrink() {
        while (size() &amp;&amp; this-&gt;back() == 0) this-&gt;pop_back();
        return *this;
    }
};
using FPS = FormalPowerSeries&lt;mint&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golden-section-search-é»„é‡‘åˆ†å‰²æ¢ç´¢"><a class="header" href="#golden-section-search-é»„é‡‘åˆ†å‰²æ¢ç´¢">Golden Section Search (é»„é‡‘åˆ†å‰²æ¢ç´¢)</a></h1>
<p>é»„é‡‘åˆ†å‰²æ¢ç´¢ (ä¸‰åˆ†æ¢ç´¢ã®ä¸€ã¤)ã€‚å˜å³°é–¢æ•°ã®å¤§åŸŸæœ€å¤§å€¤ (å¤§åŸŸæœ€å°å€¤) ã‚’æ±‚ã‚ã‚‹ã€‚äºŒåˆ†æ¢ç´¢ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåŒ–ã™ã‚‹ã¾ã§ã‚‚ãªã„ãŒã€(é»„é‡‘åˆ†å‰²æ¢ç´¢ã‚‚å«ã‚ã¦) ä¸‰åˆ†æ¢ç´¢ã¯ <code>is_convex_upward</code> ãŒ <code>true</code> ã‹å¦ã‹ã«ã‚ˆã‚Šå®Ÿè£…ãŒå°‘ã—å¤‰ã‚ã‚‹ã®ã§ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåŒ–ã—ã¦ãŠãã¨ä¾¿åˆ©ã€‚</p>
<ul>
<li><code>golden_section_search(l_lim, r_lim, f, is_convex_upward)</code>: é–¢æ•° \(y = f(x)\) ã«ãŠã„ã¦å¤§åŸŸæœ€å¤§å€¤ (å¤§åŸŸæœ€å°å€¤) ã‚’å–ã‚‹ã‚ˆã†ãª \(x\) ã‚’æ±‚ã‚ã€\({x, f(x)}\) ã‚’è¿”ã™ã€‚<code>is_convex_upward</code> ã«ã¤ã„ã¦ã¯ \(f\) ãŒä¸Šã«å‡¸ãªã‚‰ <code>true</code>ã€ä¸‹ã«å‡¸ãªã‚‰ <code>false</code> ã‚’æŒ‡å®šã€‚</li>
</ul>
<h2 id="refs-2"><a class="header" href="#refs-2">Refs</a></h2>
<ul>
<li><a href="https://naoyat.hatenablog.jp/entry/2012/01/04/231801">ä¸‰åˆ†æ¢ç´¢ã¨é»„é‡‘åˆ†å‰²æ¢ç´¢</a>, naoya_t</li>
</ul>
<h2 id="impl-3"><a class="header" href="#impl-3">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
pair&lt;T, T&gt; golden_section_search(T l_lim, T r_lim, const function&lt;T(T)&gt; &amp;f, bool is_convex_upward) {
    assert(is_floating_point_v&lt;T&gt;);
    static constexpr T phi = (1 + sqrtl(5)) / 2, TINF = numeric_limits&lt;T&gt;::max();
    T l = l_lim, l2 = TINF, r2 = TINF, r = r_lim, f_l2 = TINF, f_r2 = TINF;
    using Comp = function&lt;bool(T, T)&gt;;
    const Comp comp = is_convex_upward ? (Comp)less&lt;T&gt;() : (Comp)greater&lt;T&gt;();
    while (l + 1e-10 &lt; r) {
        if (l2 == TINF) l2 = (l * phi + r) / (phi + 1), f_l2 = f(l2);
        if (r2 == TINF) r2 = (l + r * phi) / (phi + 1), f_r2 = f(r2);
        if (comp(f_l2, f_r2)) {
            l = l2, l2 = r2, r2 = TINF, f_l2 = f_r2;
        } else {
            r = r2, r2 = l2, l2 = TINF, f_r2 = f_l2;
        }
    }
    if (f_r2 == TINF) f_r2 = f(r);
    return {r, f_r2};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lagrange-interpolation-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥å¤šé …å¼è£œé–“"><a class="header" href="#lagrange-interpolation-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥å¤šé …å¼è£œé–“">Lagrange Interpolation (ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥å¤šé …å¼è£œé–“)</a></h1>
<p>ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥å¤šé …å¼è£œé–“ã€‚</p>
<ul>
<li>constructor <code>LagrangeInterpolation(v)</code>: é…åˆ— <code>v</code> ã§åˆæœŸåŒ–ã€‚ \(\Theta(d)\)</li>
<li><code>operator()</code>: \(\Theta(d)\)</li>
</ul>
<h2 id="refs-3"><a class="header" href="#refs-3">Refs</a></h2>
<ul>
<li><a href="https://youtu.be/FhQVDtJyM6o&amp;t=9277s">AtCoder Beginner Contest 208</a>, AtCoder Live, snuke</li>
</ul>
<h2 id="impl-4"><a class="header" href="#impl-4">Impl</a></h2>
<pre><code class="language-cpp">#include &quot;algebra/modular.hpp&quot;

struct LagrangeInterpolation {
    int d;
    vector&lt;mint&gt; a;
    LagrangeInterpolation(vector&lt;mint&gt; &amp;v) : d(v.size() - 1), a(d + 1) {
        vector&lt;mint&gt; f(d + 1, 1);
        for (int i = 1; i &lt; d + 1; i++) f[i] = f[i - 1] * i;
        for (int i = 0; i &lt;= d; i++) {
            a[i] = v[i] / (f[i] * f[d - i]);
            if ((d - i) &amp; 1) a[i] *= -1;
        }
    }
    mint operator()(mint x) {
        vector&lt;mint&gt; r(d + 1, 1);
        for (int i = d - 1; i &gt;= 0; i--) r[i] = r[i + 1] * (x - i - 1);
        mint l = 1, res;
        for (int i = 0; i &lt;= d; i++) res += a[i] * l * r[i], l *= x - i;
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-sieve-ç·šå½¢ç¯©æ·»ãˆå­—-gcd-ç•³ã¿è¾¼ã¿"><a class="header" href="#linear-sieve-ç·šå½¢ç¯©æ·»ãˆå­—-gcd-ç•³ã¿è¾¼ã¿">Linear Sieve (ç·šå½¢ç¯©ã€æ·»ãˆå­— gcd ç•³ã¿è¾¼ã¿)</a></h1>
<p>ç·šå½¢ç¯©ãƒ»æœ€å°ç´ å› æ•°(<code>min_factors</code>)ãƒ»GCD ç•³ã¿è¾¼ã¿ã®ç›¸æ€§ãŒã„ã„ã“ã¨ã‚’è¦‹ã¤ã‘ãŸã®ã§ä½œã‚Šã¾ã—ãŸã€‚ã§ãã‚‹ã“ã¨ã¯ä»¥ä¸‹ã®äºŒã¤ã§ã™ã€‚</p>
<ul>
<li>å‰è¨ˆç®—ã«ã‚ˆã‚‹é«˜é€Ÿç´ å› æ•°åˆ†è§£ \(O(d(x))\)</li>
<li>GCD ç•³ã¿è¾¼ã¿ \(O(\pi(x))\)</li>
</ul>
<p>ã¾ãŸã€è¨ˆç®—é‡è¡¨è¨˜ã«ãŠã„ã¦ã€</p>
<ul>
<li>\(d(x) := (x ã®æŒã¤ç´„æ•°ã®å€‹æ•°) = O(\sqrt{x})\)</li>
<li>\(\pi(x) := (x ä»¥ä¸‹ã§ã‚ã‚‹ç´ æ•°ã®å€‹æ•°) = O(\frac{x}{\log x})\)</li>
</ul>
<p>ã‚’ç”¨ã„ã¾ã™ã€‚</p>
<ul>
<li>constructor <code>LinearSieve(n, calcs_mob)</code>: ç´ å› æ•°åˆ†è§£ã™ã‚‹è‡ªç„¶æ•°ã®æœ€å¤§å€¤ã‚’ <code>n</code>ã€ãƒ¡ãƒ“ã‚¦ã‚¹é–¢æ•°å€¤ã®é…åˆ— <code>mob</code> ã‚’æ§‹ç¯‰ã™ã‚‹ã‹ã‚’ <code>calcs_mob</code> ã¨ã—ã¦æŒ‡å®šã€‚ç·šå½¢ç¯©ã«ã‚ˆã‚Š <code>min_factors</code>ã€<code>primes</code> ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚ãªãŠã€<code>min_factors[x]</code> \(:= (æ•´æ•° x ã®æŒã¤æœ€å°ã®ç´ å› æ•°)\) ã§ã™ã€‚ \(\Theta(n)\)</li>
<li><code>factorize(x)</code>: ç·šå½¢ç¯©ã§å‰è¨ˆç®—ã—ãŸ <code>min_factors</code> ã‚’ç”¨ã„ãŸè‡ªç„¶æ•° <code>x</code> ã®ç´ å› æ•°åˆ†è§£ã®çµæœã‚’è¿”ã™ã€‚int ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ãªã„ç¯„å›²ã®ã¿å¯¾å¿œã€‚ \(O(d(x))\)<br />
e.g. <code>7007 -&gt; [(7, 2), (11, 1), (13, 1)]</code></li>
<li><code>divisors(x, sorted)</code>: <code>factorize(x)</code> ã‚’ç”¨ã„ã¦æ±‚ã‚ãŸè‡ªç„¶æ•° <code>x</code> ã®ç´„æ•°ã®é…åˆ—ã‚’è¿”ã™ã€‚<code>sorted</code> ãŒ false ã®ã¨ãã¯æœªã‚½ãƒ¼ãƒˆã§è¿”ã™ã€‚ \(O(d(x))\)</li>
<li><code>f1(F)</code>: <code>mob</code> ã‚’ç”¨ã„ã¦è¨ˆç®—ã—ã¦ <code>mobius(F)[1]</code> ã‚’è¿”ã™ã€‚ \(O(m)\) (ãŸã ã— \(m := |F|\))</li>
<li><code>zeta(f)</code>: <code>primes</code> ã‚’ç”¨ã„ã¦ã€ç´„æ•°ç³»ã®é«˜é€Ÿ zeta å¤‰æ›ã‚’è¡Œã†ã€‚ \(O(\pi(m))\) (ãŸã ã— \(m := |f|\))</li>
<li><code>mobius(F)</code>: <code>primes</code> ã‚’ç”¨ã„ã¦ã€ç´„æ•°ç³»ã®é«˜é€Ÿ mobius å¤‰æ›ã‚’è¡Œã†ã€‚ \(O(\pi(m))\) (ãŸã ã— \(m := |F|\))</li>
<li><code>gcd_conv(f, g)</code>: é–¢æ•° <code>f</code>ã€<code>g</code> ã‚’æ·»ãˆå­— GCD ç•³ã¿è¾¼ã¿ã—ã¦å¾—ãŸ <code>h</code> ã‚’è¿”ã™ã€‚ \(O(\pi(m))\) (ãŸã ã— \(m := max(|f|, |g|)\))<br />
e.g. <code>f: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]ã€g: [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]</code> ã®ã¨ã<br />
<code>h: [0, 6336, 1670, 915, 684, 230, 336, 91, 120, 153, 190, 231, 276]</code> ã¨ãªã‚‹ã€‚</li>
</ul>
<h2 id="refs-4"><a class="header" href="#refs-4">Refs</a></h2>
<h3 id="ç·šå½¢ç¯©"><a class="header" href="#ç·šå½¢ç¯©">ç·šå½¢ç¯©</a></h3>
<ul>
<li><a href="https://kanpurin.hatenablog.com/entry/2021/08/14/115825">ã€ç«¶ãƒ—ãƒ­ã€‘æ•°å­¦ãƒ¡ãƒ¢</a>, kanpurin</li>
</ul>
<h3 id="æ·»ãˆå­—-gcd-ç•³ã¿è¾¼ã¿"><a class="header" href="#æ·»ãˆå­—-gcd-ç•³ã¿è¾¼ã¿">æ·»ãˆå­— gcd ç•³ã¿è¾¼ã¿</a></h3>
<ul>
<li><a href="https://drken1215.hatenablog.com/entry/2020/11/06/031600">AtCoder AGC 038 C - LCMs (é»„è‰², 700 ç‚¹)</a>, drken</li>
<li><a href="https://noshi91.hatenablog.com/entry/2019/09/23/002445">æ·»ãˆå­— gcd ã§ã®ç•³ã¿è¾¼ã¿ã§ AGC038-C ã‚’è§£ã</a>, noshi91</li>
</ul>
<h3 id="ç´ æ•°ã®å€‹æ•°ã®ä¸Šã‹ã‚‰ã®è©•ä¾¡"><a class="header" href="#ç´ æ•°ã®å€‹æ•°ã®ä¸Šã‹ã‚‰ã®è©•ä¾¡">ç´ æ•°ã®å€‹æ•°ã®ä¸Šã‹ã‚‰ã®è©•ä¾¡</a></h3>
<ul>
<li><a href="https://maspypy.com/%E7%B4%A0%E6%95%B0%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E4%B8%8A%E3%81%8B%E3%82%89%E3%81%AE%E8%A9%95%E4%BE%A1%EF%BC%88%E5%88%9D%E7%AD%89%E7%9A%84%E3%81%AA%E8%A8%BC%E6%98%8E%EF%BC%89">ç´ æ•°ã«é–¢ã™ã‚‹ä¸Šã‹ã‚‰ã®è©•ä¾¡ï¼ˆåˆç­‰çš„ãªè¨¼æ˜ï¼‰</a>, maspy</li>
</ul>
<h2 id="impl-5"><a class="header" href="#impl-5">Impl</a></h2>
<pre><code class="language-cpp">struct LinearSieve {
    int _n;
    vector&lt;int&gt; min_factors, primes, mob;
    LinearSieve(int n, bool calcs_mob = false) : _n(n), min_factors(_n + 1) {
        iota(min_factors.begin(), min_factors.end(), 0);
        if (calcs_mob) mob.assign(_n + 1, -1), mob[1] = 1;
        for (int i = 2; i &lt;= _n; i++) {
            if (min_factors[i] == i) primes.push_back(i);
            int p_lim = min(min_factors[i], _n / i);
            for (auto &amp;p : primes) {
                if (p &gt; p_lim) break;
                min_factors[i * p] = p;
                if (calcs_mob) mob[i * p] = min_factors[i] == p ? 0 : -mob[i];
            }
        }
    }
    vector&lt;pair&lt;int, int&gt;&gt; factorize(int x) {
        assert(0 &lt; x &amp;&amp; x &lt;= _n);
        vector&lt;pair&lt;int, int&gt;&gt; factors;
        for (int cur = min_factors[x], ex = 0;; ex++, x /= min_factors[x]) {
            if (cur != min_factors[x]) {
                factors.emplace_back(cur, ex);
                if (x == 1) break;
                cur = min_factors[x], ex = 0;
            }
        }
        return factors;
    }
    vector&lt;int&gt; divisors(int x, bool sorted = false) {
        vector&lt;int&gt; divs{1};
        vector&lt;pair&lt;int, int&gt;&gt; factors = factorize(x);
        for (auto &amp;[b, ex] : factors) {
            int sz = divs.size();
            for (int i = 0; i &lt; sz; i++) {
                int mul = divs[i];
                for (int j = 0; j &lt; ex; j++) divs.push_back(mul *= b);
            }
        }
        if (sorted) sort(divs.begin(), divs.end());
        return divs;
    }
    template &lt;class T&gt;
    T f1(vector&lt;T&gt; &amp;F) {
        int sz = F.size();
        assert(sz - 1 &lt;= _n &amp;&amp; !mob.empty());
        T res = 0;
        for (int i = 0; i &lt; sz; i++) res += F[i] * mob[i];
        return res;
    }
    template &lt;class T&gt;
    void zeta(vector&lt;T&gt; &amp;f) {
        int sz = f.size();
        assert(sz - 1 &lt;= _n);
        for (auto &amp;p : primes) {
            if (p &gt;= sz) break;
            for (int i = (sz - 1) / p; i &gt;= 1; i--) f[i] += f[i * p];
        }
    }
    template &lt;class T&gt;
    void mobius(vector&lt;T&gt; &amp;F) {
        int sz = F.size();
        assert(sz - 1 &lt;= _n);
        for (auto &amp;p : primes) {
            if (p &gt;= sz) break;
            for (int i = 1; i * p &lt; sz; i++) F[i] -= F[i * p];
        }
    }
    template &lt;class T&gt;
    vector&lt;T&gt; gcd_conv(vector&lt;T&gt; f, vector&lt;T&gt; g, bool is_square = false) {
        int sz = max(f.size(), g.size());
        f.resize(sz, 0), g.resize(sz, 0);
        zeta(f);
        is_square ? void(g = f) : zeta(g);
        vector&lt;T&gt; H(sz);
        for (int i = 1; i &lt; sz; i++) H[i] = f[i] * g[i];
        mobius(H);
        return H;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modular-å‰°ä½™ç’°ä¸Šã®å‹"><a class="header" href="#modular-å‰°ä½™ç’°ä¸Šã®å‹">Modular (å‰°ä½™ç’°ä¸Šã®å‹)</a></h1>
<p>è‡ªå‹•ã§ mod ã‚’å–ã‚‹æ§‹é€ ä½“ã€‚</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-cpp">// #include ã®ä¸Šã« const int MOD = 1e9 + 7; ã‚„
// const int MOD = 998244353; ã‚’æ›¸ã„ã¦ã‹ã‚‰ä½¿ã£ã¦ãã ã•ã„ã€‚
const int MOD = 1e9 + 7;
#include &quot;algebra/modular.hpp&quot;
int main() {
    mint ans = 0;
    // (ä¸­ç•¥)
    return 0;
}
</code></pre>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<ul>
<li>æ¼”ç®—:
<ul>
<li>å‰²ã‚Šç®—: \(O(\log n)\)</li>
<li>å‰²ã‚Šç®—ä»¥å¤–: \(O(1)\)</li>
</ul>
</li>
<li><code>mod()</code>: \(O(1)\)</li>
<li><code>val()</code>: \(O(1)\)</li>
<li><code>pow(n)</code>: \(O(\log n)\)</li>
<li><code>inv()</code>: \(O(\log MOD)\)</li>
</ul>
<h2 id="refs-5"><a class="header" href="#refs-5">Refs</a></h2>
<ul>
<li><a href="https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp">https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp</a></li>
</ul>
<h2 id="impl-6"><a class="header" href="#impl-6">Impl</a></h2>
<pre><code class="language-cpp">#ifndef MODULAR_HPP
#define MODULAR_HPP

template &lt;int m&gt;
struct Modular {
   private:
    uint _v;
    using mint = Modular;

   public:
    constexpr Modular() : _v(0) {}
    constexpr Modular(long long v) {
        v %= 1ll * m;
        _v = v &lt; 0 ? v + m : v;
    };
    mint &amp;operator++() {
        if (++_v == umod()) _v = 0;
        return *this;
    }
    mint &amp;operator--() {
        if (_v == 0) _v = umod();
        return _v--, *this;
    }
    mint operator++(int) {
        mint res = *this;
        return ++*this, res;
    }
    mint operator--(int) {
        mint res = *this;
        return --*this, res;
    }
    constexpr mint operator-() { return mint() - *this; }
    mint operator+(const mint &amp;rhs) { return mint(*this) += rhs; }
    mint operator-(const mint &amp;rhs) { return mint(*this) -= rhs; }
    mint operator*(const mint &amp;rhs) { return mint(*this) *= rhs; }
    mint operator/(const mint &amp;rhs) { return mint(*this) /= rhs; }
    mint &amp;operator+=(const mint &amp;rhs) {
        _v += rhs._v;
        if (_v &gt;= umod()) _v -= umod();
        return *this;
    }
    mint &amp;operator-=(const mint &amp;rhs) {
        _v -= rhs._v;
        if (_v &gt;= umod()) _v += umod();
        return *this;
    }
    mint &amp;operator*=(const mint &amp;rhs) {
        _v = 1ll * _v * rhs._v % umod();
        return *this;
    }
    mint &amp;operator/=(const mint &amp;rhs) { return *this = *this * rhs.inv(); }
    friend mint operator+(const mint &amp;lhs, const mint &amp;rhs) { return mint(lhs) += rhs; }
    friend mint operator-(const mint &amp;lhs, const mint &amp;rhs) { return mint(lhs) -= rhs; }
    friend mint operator*(const mint &amp;lhs, const mint &amp;rhs) { return mint(lhs) *= rhs; }
    friend mint operator/(const mint &amp;lhs, const mint &amp;rhs) { return mint(lhs) /= rhs; }
    bool operator==(const mint &amp;rhs) { return this-&gt;_v == rhs._v; }
    bool operator!=(const mint &amp;rhs) { return this-&gt;_v != rhs._v; }
    static constexpr int mod() { return m; }
    constexpr uint val() const { return _v; }
    mint pow(long long n) const {
        mint x = *this, res = 1;
        while (n) {
            if (n &amp; 1) res *= x;
            x *= x, n /= 2;
        }
        return res;
    }
    mint inv() const { return pow(umod() - 2); }
    friend istream &amp;operator&gt;&gt;(istream &amp;is, mint &amp;x) {
        long long _v;
        return is &gt;&gt; _v, x = _v, is;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const mint&amp; x) { return os &lt;&lt; x.val(); }

   private:
    static constexpr uint umod() { return m; }
};
using mint = Modular&lt;MOD&gt;;
constexpr mint operator&quot;&quot;_M(unsigned long long x) { return mint(x); }

#endif  // MODULAR_HPP
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rational-æœ‰ç†æ•°å‹"><a class="header" href="#rational-æœ‰ç†æ•°å‹">Rational (æœ‰ç†æ•°å‹)</a></h1>
<h2 id="refs-6"><a class="header" href="#refs-6">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/math/rational/rational.hpp">https://ei1333.github.io/library/math/rational/rational.hpp</a>, ei1333</li>
</ul>
<h2 id="impl-7"><a class="header" href="#impl-7">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Rational {
   public:
//    private:
    T _nume, _deno;

//    public:
    Rational(T n = 0, T d = 1) : _nume(n), _deno(d) { normalize(); }
    Rational &amp;operator=(T n) { return assign(n, 1); }
    Rational &amp;assign(T n = 0, T d = 1) { return _nume = n, _deno = d, normalize(), *this; }
    T nume() const { return _nume; }
    T deno() const { return _deno; }
    Rational &amp;operator+=(Rational &amp;r) {
        T g = gcd(_deno, r._deno);
        _deno /= g, _nume = _nume * (r._deno / g) + r._nume * _deno;
        g = gcd(_nume, g), _nume /= g, _deno *= r._deno / g;
        return *this;
    }
    Rational &amp;operator-=(const Rational &amp;r) {
        T g = gcd(_deno, r._deno);
        _deno /= g, _nume = _nume * (r._deno / g) - r._nume * _deno;
        g = gcd(_nume, g), _nume /= g, _deno *= r._deno / g;
        return *this;
    }
    Rational &amp;operator*=(const Rational &amp;r) {
        T g1 = gcd(_nume, r._deno), g2 = gcd(_deno, r._nume);
        _nume = (_nume / g1) * (r._nume / g2), _deno = (_deno / g2) * (r._deno / g1);
        return *this;
    }
    Rational &amp;operator/=(const Rational &amp;r) {
        T g1 = gcd(_nume, r._nume), g2 = gcd(_deno, r._deno);
        _nume = (_nume / g1) * (r._deno / g2), _deno = (_deno / g2) * (r._nume / g1);
        if (_deno &lt; 0) _nume = -_nume, _deno = -_deno;
        return *this;
    }
    Rational &amp;operator+=(const T &amp;i) { return (*this) += Rational{i}; }
    Rational &amp;operator-=(const T &amp;i) { return (*this) -= Rational{i}; }
    Rational &amp;operator*=(const T &amp;i) { return (*this) *= Rational{i}; }
    Rational &amp;operator/=(const T &amp;i) { return (*this) /= Rational{i}; }
    Rational operator+(const Rational &amp;r) const { return Rational(*this) += r; }
    Rational operator-(const Rational &amp;r) const { return Rational(*this) -= r; }
    Rational operator*(const Rational &amp;r) const { return Rational(*this) *= r; }
    Rational operator/(const Rational &amp;r) const { return Rational(*this) /= r; }
    Rational operator+(const T &amp;i) const { return Rational(*this) += i; }
    Rational operator-(const T &amp;i) const { return Rational(*this) -= i; }
    Rational operator*(const T &amp;i) const { return Rational(*this) *= i; }
    Rational operator/(const T &amp;i) const { return Rational(*this) /= i; }
    Rational operator-() const { return Rational{-_nume, _deno}; }
    Rational &amp;operator++() { return _nume += _deno, *this; }
    Rational &amp;operator--() { return _nume -= _deno, *this; }
    bool operator==(const Rational &amp;r) const { return _nume * r._deno == r._nume * _deno; }
    bool operator!=(const Rational &amp;r) const { return _nume * r._deno != r._nume * _deno; }
    bool operator&lt;(const Rational &amp;r) const { return _nume * r._deno &lt; r._nume * _deno; }
    bool operator&gt;(const Rational &amp;r) const { return _nume * r._deno &gt; r._nume * _deno; }
    bool operator&lt;=(const Rational &amp;r) const { return _nume * r._deno &lt;= r._nume * _deno; }
    bool operator&gt;=(const Rational &amp;r) const { return _nume * r._deno &gt;= r._nume * _deno; }
    template &lt;class Real = double&gt;
    Real to_double() const { return Real(_nume) / _deno; }
    Rational abs() const { return Rational{_nume &gt; 0 ? _nume : -_nume, _deno}; }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Rational &amp;r) {
        return os &lt;&lt; r._nume &lt;&lt; '/' &lt;&lt; r._deno, os;
    }

   private:
    static T gcd(T a, T b) { return __gcd(a &gt; 0 ? a : a, b &gt; 0 ? b : b); }
    void normalize() {
        if (_nume == 0) return _deno = 1, void();
        if (_nume == 1 || _deno == 1) return;
        T g = gcd(_nume, _deno);
        _nume /= g, _deno /= g;
        if (_deno &lt; 0) _nume = -_nume, _deno = -_deno;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slide-ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤æœ€å¤§å€¤"><a class="header" href="#slide-ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤æœ€å¤§å€¤">Slide (ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤ãƒ»æœ€å¤§å€¤)</a></h1>
<ul>
<li><code>slide(v, k, is_mn)</code>: <code>v</code> ã«å«ã¾ã‚Œã‚‹å¹… <code>k</code> ã®å„åŒºé–“ã«å¯¾ã™ã‚‹æœ€å°å€¤ãƒ»æœ€å¤§å€¤ã‚’æ ¼ç´ã—ãŸé…åˆ—ã‚’è¿”ã™ã€‚<code>is_mn</code> ãŒ <code>true</code> ãªã‚‰ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤ã€<code>false</code> ãªã‚‰ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å¤§å€¤ã€‚</li>
</ul>
<h2 id="refs-7"><a class="header" href="#refs-7">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/luzhiled/snippets/dp/slide-min.html">https://ei1333.github.io/luzhiled/snippets/dp/slide-min.html</a>, ei1333</li>
</ul>
<h2 id="impl-8"><a class="header" href="#impl-8">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
vector&lt;T&gt; slide(const vector&lt;T&gt; &amp;v, int k, bool is_mn) {
    int n = v.size();
    assert(n &gt;= k);
    deque&lt;int&gt; q;
    vector&lt;T&gt; res;
    res.reserve(n - k + 1);
    using Comp = function&lt;bool(T, T)&gt;;
    Comp comp = is_mn ? Comp(greater_equal&lt;T&gt;()) : Comp(less_equal&lt;T&gt;());
    for (int i = 0; i &lt; n; i++) {
        while (!q.empty() &amp;&amp; comp(v[q.back()], v[i])) q.pop_back();
        q.push_back(i);
        if (i &gt;= k - 1) {
            res.push_back(v[q.front()]);
            if (q.front() == i - k + 1) q.pop_front();
        }
    }
    return res;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="square-matrix-æ­£æ–¹è¡Œåˆ—ã®ç´¯ä¹—"><a class="header" href="#square-matrix-æ­£æ–¹è¡Œåˆ—ã®ç´¯ä¹—">Square Matrix (æ­£æ–¹è¡Œåˆ—ã®ç´¯ä¹—)</a></h1>
<p>æ­£æ–¹è¡Œåˆ—ã®ç´¯ä¹—ã€‚</p>
<ul>
<li>constructor <code>SquareMatrix(n)</code>: <code>n</code> è¡Œ <code>n</code> åˆ—ã®è¡Œåˆ—ã‚’ä½œã‚Šã€å…¨è¦ç´ ã‚’ \(0\) ã§åˆæœŸåŒ–ã€‚ \(\Theta(n^2)\)</li>
<li><code>pow(x)</code>: è¡Œåˆ—ç´¯ä¹—ã€‚ \(\Theta(n^3 \log x)\)</li>
<li><code>print()</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ \(\Theta(n^2)\)</li>
</ul>
<h2 id="refs-8"><a class="header" href="#refs-8">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/math/matrix/square-matrix.cpp">https://ei1333.github.io/library/math/matrix/square-matrix.cpp</a></li>
</ul>
<h2 id="impl-9"><a class="header" href="#impl-9">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct SquareMatrix {
   private:
    int _n;
    T **mat;

   public:
    SquareMatrix() {}
    SquareMatrix(int n) : _n(n) {
        mat = new T *[_n];
        for (int i = 0; i &lt; _n; i++) {
            mat[i] = new T[_n];
            for (int j = 0; j &lt; _n; j++) mat[i][j] = 0;
        }
    }
    T &amp;operator()(int i, int j) const {
        assert(0 &lt;= i &amp;&amp; i &lt; _n &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; _n);
        return mat[i][j];
    }
    SquareMatrix &amp;operator*=(const SquareMatrix &amp;a) {
        SquareMatrix mul(_n);
        for (int i = 0; i &lt; _n; i++) {
            for (int j = 0; j &lt; a._n; j++) {
                for (int k = 0; k &lt; _n; k++) mul(i, j) = (mul(i, j) + mat[i][k] * a(k, j));
            }
        }
        swap(mat, mul.mat);
        return *this;
    }
    SquareMatrix operator*(const SquareMatrix &amp;a) const { return SquareMatrix(*this) *= a; }
    static SquareMatrix id_mat(int m) {
        SquareMatrix id(m);
        for (int i = 0; i &lt; m; i++) id(i, i) = 1;
        return id;
    }
    SquareMatrix pow(long long x) {
        SquareMatrix a(*this), res(SquareMatrix::id_mat(_n));
        while (x) {
            if (x &amp; 1) res *= a;
            a *= a, x /= 2;
        }
        return res;
    }
    void print() {
#ifdef _DEBUG
        for (int i = 0; i &lt; _n; i++) {
            cout &lt;&lt; '[';
            for (int j = 0; j &lt; _n; j++) {
                if (j) cout &lt;&lt; &quot;, &quot;;
                cout &lt;&lt; (*this)(i, j).val();
            }
            cout &lt;&lt; &quot;]\n&quot;;
        }
#endif
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/conv">lib/cpp/conv</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-fourier-transform-ffté«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›"><a class="header" href="#fast-fourier-transform-ffté«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›">Fast Fourier Transform (FFTã€é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›)</a></h1>
<ul>
<li>struct <code>Angles</code>: <code>ang[i] = (360Â° / 2^(i+1))</code> ã¨ã—ã¦ã„ã¾ã™ã€‚</li>
<li><code>fft(f, is_inverse)</code>: <code>is_inverse</code> ãŒ <code>true</code> ãªã‚‰ \(f \to F\)ã€ãã†ã§ãªã„ãªã‚‰ \(F \to f\)ã€‚</li>
<li><code>conv(f, g, is_square)</code>: é–¢æ•° <code>f</code>ã€<code>g</code> ã‚’ç•³ã¿è¾¼ã‚“ã§å¾—ãŸ <code>h</code> ã‚’è¿”ã™ã€‚<code>f</code> == <code>g</code> ãªã‚‰ <code>is_square</code> ã« <code>true</code> ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§é«˜é€ŸåŒ–ã§ãã‚‹ã€‚<code>i</code> å††ã®ä¸»èœã¨å‰¯èœã§ <code>k</code> å††å®šé£Ÿã‚’ä½œã‚‹ä½œã‚Šæ–¹ã€‚</li>
</ul>
<h2 id="refs-9"><a class="header" href="#refs-9">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/math/fft/fast-fourier-transform.cpp">https://ei1333.github.io/library/math/fft/fast-fourier-transform.cpp</a>, ei1333</li>
<li><a href="https://qiita.com/ageprocpp/items/0d63d4ed80de4a35fe79">FFTï¼ˆé«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ï¼‰ã‚’å®Œå…¨ã«ç†è§£ã™ã‚‹è©±</a>, kaage</li>
</ul>
<h2 id="impl-10"><a class="header" href="#impl-10">Impl</a></h2>
<pre><code class="language-cpp">struct Com {
    double re, im;
    constexpr Com() : re(), im() {}
    constexpr Com(double _re, double _im) : re(_re), im(_im) {}
    double real() { return re; }
    double imag() { return im; }
    Com operator+(Com &amp;c) { return {re + c.re, im + c.im}; }
    Com operator-(Com &amp;c) { return {re - c.re, im - c.im}; }
    Com operator*(Com &amp;c) { return {re * c.re - im * c.im, re * c.im + im * c.re}; }
    Com operator/(double d) { return {re / d, im / d}; }
    Com &amp;operator*=(Com &amp;c) { return *this = (*this) * c; }
    Com &amp;operator/=(double d) { return *this = (*this) / d; }
    friend Com conj(Com c) { return {c.re, -c.im}; }
};
struct Angles {
    static constexpr int I_MAX = 30;
    Com z[I_MAX];
    constexpr Angles() : z() {
        for (int i = 0; i &lt; I_MAX; i++) {
            double ang = 2 * M_PI / (1 &lt;&lt; (i + 1));
            z[i] = {cos(ang), sin(ang)};
        }
    }
    Com operator[](int i) const {
        assert(0 &lt;= i &amp;&amp; i &lt; I_MAX);
        return z[i];
    }
};
constexpr Angles ang;
void fft(vector&lt;Com&gt; &amp;f, bool is_inverse) {
    int n = f.size();
    for (int i = 0, j = 1; j &lt; n; j++) {
        for (int k = n &gt;&gt; 1; k &gt; (i ^= k); k &gt;&gt;= 1) {}
        if (i &gt; j) swap(f[i], f[j]);
    }
    for (int k = 0, t = 1; t &lt; n; ++k, t &lt;&lt;= 1) {
        Com bw = is_inverse ? conj(ang[k]) : ang[k];
        for (int i = 0; i &lt; n; i += t * 2) {
            Com w(1, 0);
            for (int j = 0; j &lt; t; j++) {
                int l = i + j, r = i + j + t;
                Com c = f[l], d = f[r] * w;
                f[l] = c + d, f[r] = c - d, w *= bw;
            }
        }
    }
    if (is_inverse) {
        for (int i = 0; i &lt; n; i++) f[i] /= n;
    }
}
template &lt;class T&gt;
vector&lt;T&gt; conv(const vector&lt;T&gt; &amp;f, const vector&lt;T&gt; &amp;g, bool is_square = false) {
    int f_deg = f.size(), g_deg = g.size(), n = 1;
    while (n &lt; f_deg + g_deg) n &lt;&lt;= 1;
    vector&lt;Com&gt; _f(n, Com(0, 0)), _g(n, Com(0, 0));
    for (int i = 0; i &lt; f_deg; i++) _f[i] = {(double)f[i], 0};
    for (int i = 0; i &lt; g_deg; i++) _g[i] = {(double)g[i], 0};
    fft(_f, false);
    is_square ? void(_g = _f) : fft(_g, false);
    for (int i = 0; i &lt; n; i++) _f[i] *= _g[i];
    fft(_f, true);
    int h_deg = f_deg + g_deg - 1;
    vector&lt;T&gt; h(h_deg);
    for (int i = 0; i &lt; h_deg; i++) h[i] = (T)round(_f[i].real());
    return h;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-theoretic-transform-nttæ•°è«–å¤‰æ›"><a class="header" href="#number-theoretic-transform-nttæ•°è«–å¤‰æ›">Number Theoretic Transform (NTTã€æ•°è«–å¤‰æ›)</a></h1>
<p>æ•°è«–å¤‰æ›ã€‚</p>
<ul>
<li><code>NumberTheoreticTransform&lt;m&gt;()</code>: æ³•ã‚’ <code>m</code> ã¨ã™ã‚‹ã€‚
æœ‰åŠ¹ãªç´ æ•° <code>m</code> ã®å€™è£œã‚’ 3 ã¤æŒ™ã’ã‚Œã°ã€
<ul>
<li>\(924844033 = 2^{21} \times 3^2 \times 7^2 + 1\)</li>
<li>\(998244353 = 2^{23} \times 119 + 1\)</li>
<li>\(1012924417 = 2^{21} \times 3 \times 7 \times 23 + 1\)</li>
</ul>
</li>
<li><code>ntt(f)</code>: \(f \to F\) ã€‚</li>
<li><code>conv(f, g, is_square)</code>: é–¢æ•° <code>f</code>ã€<code>g</code> ã‚’ç•³ã¿è¾¼ã‚“ã§å¾—ãŸ <code>h</code> ã‚’è¿”ã™ã€‚<code>f</code> == <code>g</code> ãªã‚‰ <code>is_square</code> ã§é«˜é€ŸåŒ–ã§ãã‚‹ã€‚<code>i</code> å††ã®ä¸»èœã¨å‰¯èœã§ <code>k</code> å††å®šé£Ÿã‚’ä½œã‚‹ä½œã‚Šæ–¹ã€‚</li>
</ul>
<h2 id="refs-10"><a class="header" href="#refs-10">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/math/fft/number-theoretic-transform.cpp">https://ei1333.github.io/library/math/fft/number-theoretic-transform.cpp</a>, ei1333</li>
<li><a href="https://qiita.com/peria/items/f6912f6d91db409ca87a">FFTã¨NTTã¨FMTã¨</a>, Peria</li>
<li><a href="https://qiita.com/Sen_comp/items/9401382df736e51564c1">NTT(æ•°è«–å¤‰æ›)ã®ã‚„ã•ã—ã„è§£èª¬</a>, Sen_comp</li>
</ul>
<h2 id="impl-11"><a class="header" href="#impl-11">Impl</a></h2>
<pre><code class="language-cpp">#include &quot;algebra/modular.hpp&quot;

template &lt;int m&gt;
struct NumberTheoreticTransform {
   private:
    vector&lt;int&gt; rev{0, 1};
    vector&lt;mint&gt; rts{0_M, 1_M};
    // vector&lt;mint&gt; rts;
    int base = 1, max_base = 0;
    mint root = 2;

   public:
    constexpr NumberTheoreticTransform() {
        // rts.push_back(0);
        // rts.push_back(1);
        assert(m &gt;= 3 &amp;&amp; m % 2 == 1);
        int tmp = m - 1;
        while (tmp % 2 == 0) tmp &gt;&gt;= 1, max_base++;
        while (root.pow((m - 1) &gt;&gt; 1) == 1_M) root++;
        assert(root.pow(m - 1) == 1_M);
        root = root.pow((m - 1) &gt;&gt; max_base);
    }
    void ntt(vector&lt;mint&gt; &amp;f) {
        int n = f.size(), zeros = __builtin_ctz(n), shift = base - zeros;
        assert((n &amp; (n - 1)) == 0);
        ensure_base(zeros);
        for (int i = 0; i &lt; n; i++) {
            if (i &lt; (rev[i] &gt;&gt; shift)) swap(f[i], f[rev[i] &gt;&gt; shift]);
        }
        for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
            for (int i = 0; i &lt; n; i += 2 * k) {
                for (int j = 0; j &lt; k; ++j) {
                    mint z = f[i + j + k] * rts[j + k];
                    f[i + j + k] = f[i + j] + m - z;
                    f[i + j] = f[i + j] + z;
                }
            }
        }
    }
    vector&lt;mint&gt; conv(vector&lt;mint&gt; f, vector&lt;mint&gt; g, bool is_square = false) {
        int h_deg = f.size() + g.size() - 1, n_base = 1;
        while ((1 &lt;&lt; n_base) &lt; h_deg) n_base++;
        ensure_base(n_base);
        int sz = 1 &lt;&lt; n_base;
        f.resize(sz, 0), g.resize(sz, 0);
        ntt(f);
        is_square ? void(g = f) : ntt(g);
        mint sz_inv = mint(sz).inv();
        for (int i = 0; i &lt; sz; i++) f[i] *= g[i] * sz_inv;
        reverse(f.begin() + 1, f.end());
        ntt(f);
        f.resize(h_deg);
        return f;
    }

   private:
    void ensure_base(int n_base) {
        if (n_base &lt;= base) return;
        rev.resize(1 &lt;&lt; n_base), rts.resize(1 &lt;&lt; n_base);
        for (int i = 0; i &lt; (1 &lt;&lt; n_base); i++) {
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (n_base - 1));
        }
        assert(n_base &lt;= max_base);
        while (base &lt; n_base) {
            mint z = root.pow(1 &lt;&lt; (max_base - 1 - base));
            for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
                rts[i &lt;&lt; 1] = rts[i];
                rts[(i &lt;&lt; 1) + 1] = rts[i] * z;
            }
            base++;
        }
    }
};
NumberTheoreticTransform&lt;MOD&gt; NTT;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/data-structures">lib/cpp/data-structures</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-indexed-tree-bit"><a class="header" href="#binary-indexed-tree-bit">Binary Indexed Tree (BIT)</a></h1>
<p>ä»¥ä¸‹ã§ <code>i</code>ã€<code>l</code>ã€<code>r</code> ã¯å…¨ã¦ 1-indexed ã§ã™ã€‚<br />
0-indexed ã§å®Ÿè£…ã—ãŸã„æ–¹ã¯ <a href="https://github.com/atcoder/ac-library/blob/master/atcoder/dsu.hpp">atcoder/dsu</a> ã‚’è¦‹ã¦ãã ã•ã„ã€‚</p>
<ul>
<li>constructor <code>BinaryIndexedTree&lt;T&gt;(n)</code>: é…åˆ—ã‚µã‚¤ã‚º <code>n</code> ã§åˆæœŸåŒ–ã€‚ \(\Theta(1)\)</li>
<li><code>add(x, l, r = -1)</code>: åŒºé–“ \([l,r)\) å†…ã® \(i\) ã«å¯¾ã— <code>v[i] += x</code> ã‚’ã™ã‚‹ (åŒºé–“åŠ ç®—)ã€‚ãŸã ã— \(r\) ã‚’æœªæŒ‡å®šã ã¨ <code>v[l] += x</code> ã‚’ã™ã‚‹ (ä¸€ç‚¹åŠ ç®—)ã€‚ä¸€ç‚¹åŠ ç®—ã¨çµ±åˆã—ãŸãŸã‚ã€å¤‰å‰‡çš„ã ãŒå¼•æ•°ã‚’ <code>x</code>ã€<code>l</code>ã€<code>r</code> ã®é †ã¨ã—ã¦ã„ã‚‹ã€‚ \(O(\log n)\)</li>
<li><code>sum(i)</code>: \(\sum_{k=1}^{i} v[k]\) ã‚’è¿”ã™ã€‚å®Ÿè£…ã®éƒ½åˆä¸Šã€é–‰åŒºé–“ãªã®ã§æ³¨æ„ã€‚ \(O(\log n)\)</li>
<li><code>range_sum(l, r)</code>: \(\sum_{i=l}^{r-1} v[i]\) ã‚’è¿”ã™ã€‚ \(O(\log n)\)</li>
<li><code>operator[](i)</code>: \(v[i]\) ã‚’è¿”ã™ã€‚ \(O(\log n)\)</li>
<li><code>print()</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ \(O(n \log n)\)</li>
</ul>
<h2 id="refs-11"><a class="header" href="#refs-11">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/binary-indexed-tree/">Binary Indexed Tree (BIT) ç·ã¾ã¨ã‚ï¼åŒºé–“åŠ ç®—ã‚„äºŒæ¬¡å…ƒBITã¾ã§</a>, 634kami</li>
</ul>
<h2 id="impl-12"><a class="header" href="#impl-12">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct BinaryIndexedTree {
   private:
    int _n;
    vector&lt;vector&lt;T&gt;&gt; v;
    bool uses_raq = false;

   public:
    BinaryIndexedTree(int n) : _n(n + 1), v(2, vector&lt;T&gt;(_n)) {}
    void add(T x, int l, int r = -1) {
        if (r == -1) {
            assert(1 &lt;= l &amp;&amp; l &lt;= _n);
            _add(false, l, x);
            return;
        }
        uses_raq = true;
        assert(1 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= _n);
        _add(false, l, -x * (l - 1));
        _add(false, r, x * (r - 1));
        _add(true, l, x);
        _add(true, r, -x);
    }
    T sum(int i) {
        assert(1 &lt;= i &amp;&amp; i &lt;= _n);
        if (--i == 0) return 0;
        return uses_raq ? _sum(false, i) + _sum(true, i) * i : _sum(false, i);
    }
    T range_sum(int l, int r) {
        assert(1 &lt;= l &amp;&amp; l &lt;= _n &amp;&amp; 1 &lt;= r &amp;&amp; r &lt;= _n);
        return sum(r) - sum(l);
    }
    T operator[](int i) {
        assert(1 &lt;= i &amp;&amp; i &lt;= _n);
        return range_sum(i, i + 1);
    }
    void print() {
#ifdef _DEBUG
        for (int i = 1; i &lt; _n; i++) cout &lt;&lt; (*this)[i] &lt;&lt; ' ';
        cout &lt;&lt; '\n';
#endif
    }

   private:
    void _add(bool is_raq, int i, T x) {
        for (; i &lt; _n; i += i &amp; -i) v[is_raq][i] += x;
    }
    T _sum(bool is_raq, int i) {
        T tot = 0;
        for (; i &gt; 0; i -= i &amp; -i) tot += v[is_raq][i];
        return tot;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull-trick"><a class="header" href="#convex-hull-trick">Convex Hull Trick</a></h1>
<p>ç›´ç·š (ä¸€æ¬¡é–¢æ•°) ç¾¤ã® y ã®æœ€å°å€¤ã‚’æ±‚ã‚ã‚‹ã€‚dp ã®æ¼¸åŒ–å¼ã‚’æ•´ç†ã—ãŸã¨ããªã©ã«ã€\(\min(a_i x + b_i)\) ã®å½¢ã®å¼ã«ãªã‚‹ã¨ã Convex Hull Trick ã‚’ä½¿ãˆã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚add query ã«ã¦ã€a ãŒå˜èª¿éå¢—åŠ  (æ¸›å°‘) ã®çŠ¶æ³ã§ã®ã¿ä½¿ãˆã‚‹ã€‚</p>
<ul>
<li>constructor <code>ConvexHullTrick&lt;T&gt;(a_incr)</code>: <code>a</code> ãŒæ˜‡é †ã¨ãªã‚‹ã‚ˆã†ã« add query ã—ã¦ã„ããªã‚‰ <code>true</code>ã€é™é †ã§ add query ã™ã‚‹ãªã‚‰ <code>false</code> ã‚’æŒ‡å®šã€‚</li>
<li><code>add(a, b)</code>: ç›´ç·š \(y = ax + b\) ã‚’è¿½åŠ ã€‚</li>
<li><code>get(x)</code>: å˜èª¿æ€§ã®ãŸã‚äºŒåˆ†æ¢ç´¢ã§ãã‚‹ã€‚ \(O((n+q) \log n)\)</li>
<li><code>get_x_incr(x)</code>: get query ã® <code>x</code> ã¾ã§ã‚‚å˜èª¿ãªã‚‰ä½¿ãˆã‚‹ã€‚ \(O(n+q)\)</li>
<li>(å‚è€ƒ) private <code>necessary(p1, p2, p3)</code>:<br>
äº¤ç‚¹ã® x åº§æ¨™ã®æ¯”è¼ƒã«ã‚ˆã‚Šã€ç›´ç·š \(P_3\) ãŒå¿…è¦ã‹ã©ã†ã‹ã‚’è©•ä¾¡ã™ã‚‹ã€‚<br />
\((P_1, P_2 ã®äº¤ç‚¹ã® x åº§æ¨™) &lt; (P_2, P_3 ã®äº¤ç‚¹ã® x åº§æ¨™) \Leftrightarrow \frac{b_2 - b_1}{a_1 - a_2} &lt; \frac{b_3 - b_2}{a_2 - a_3}\)</li>
</ul>
<h2 id="refs-12"><a class="header" href="#refs-12">Refs</a></h2>
<ul>
<li><a href="https://satanic0258.hatenablog.com/entry/2016/08/16/181331">Convex-Hull Trick - sataniC++</a>, satanic0258</li>
<li><a href="https://ei1333.github.io/library/structure/convex-hull-trick/convex-hull-trick-add-monotone.cpp">https://ei1333.github.io/library/structure/convex-hull-trick/convex-hull-trick-add-monotone.cpp</a>, ei1333</li>
</ul>
<h2 id="impl-13"><a class="header" href="#impl-13">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
class ConvexHullTrick {
    deque&lt;pair&lt;T, T&gt;&gt; q;
    T prev_a;
    using Comp = function&lt;bool(T, T)&gt;;
    Comp comp;

   public:
    ConvexHullTrick(bool a_incr)
        : comp(a_incr ? Comp(less_equal&lt;T&gt;()) : Comp(greater_equal&lt;T&gt;())),
          prev_a(a_incr ? numeric_limits&lt;T&gt;::min() : numeric_limits&lt;T&gt;::max()) {}
    void add(T a, T b) {
        assert(comp(prev_a, a));
        prev_a = a;
        pair&lt;T, T&gt; t(a, b);
        while (q.size() &gt; 1 &amp;&amp; !necessary(q[q.size() - 2], q[q.size() - 1], t)) q.pop_back();
        q.push_back(t);
    }
    T get(T x) {
        assert(!q.empty());
        int ng = -1, ok = q.size() - 1;
        while (ng + 1 &lt; ok) {
            int mid = (ng + ok) / 2;
            (comp(f(mid, x), f(mid + 1, x)) ? ng : ok) = mid;
        }
        return f(ok, x);
    }
    T get_x_incr(T x) {
        assert(!q.empty());
        while (q.size() &gt; 1 &amp;&amp; comp(f(0, x), f(1, x))) q.pop_front();
        return f(0, x);
    }

   private:
    bool necessary(pair&lt;T, T&gt; &amp;p1, pair&lt;T, T&gt; &amp;p2, pair&lt;T, T&gt; &amp;p3) {
        return (__int128_t)(p2.second - p1.second) * (p2.first - p3.first) &lt;
               (__int128_t)(p3.second - p2.second) * (p1.first - p2.first);
    }
    T f(int i, T &amp;x) { return q[i].first * x + q[i].second; }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cumulative-sum-2d-äºŒæ¬¡å…ƒç´¯ç©å’Œ"><a class="header" href="#cumulative-sum-2d-äºŒæ¬¡å…ƒç´¯ç©å’Œ">Cumulative Sum 2d (äºŒæ¬¡å…ƒç´¯ç©å’Œ)</a></h1>
<ul>
<li>constructor <code>CumulativeSum2d&lt;T, is_rect_addition&gt;(h, w)</code>: <code>is_rect_addition</code> ãŒ <code>true</code> ãªã‚‰çŸ©å½¢åŠ ç®—ãƒ»ç‚¹å–å¾—ã€<code>false</code> ãªã‚‰ç‚¹åŠ ç®—ãƒ»çŸ©å½¢å’Œå–å¾—ã€‚</li>
<li><code>is_rect_addition</code> == <code>true</code> ã®ã¨ãã€‚
<ul>
<li><code>add(y1, x1, y2, x2, a)</code>: çŸ©å½¢ \([y_1, y_2) \times [x_1, x_2)\) ã« \(a\) ã‚’åŠ ç®—ã€‚</li>
<li><code>get(y, x)</code>: ç‚¹ \((y, x)\) ã®å€¤ã‚’è¿”ã™ã€‚</li>
</ul>
</li>
<li><code>is_rect_addition</code> == <code>false</code> ã®ã¨ãã€‚
<ul>
<li><code>add(y, x, a)</code>: ç‚¹ \((y, x)\) ã« \(a\) ã‚’åŠ ç®—ã€‚</li>
<li><code>get(y1, x1, y2, x2)</code>: çŸ©å½¢ \([y_1, x_1) \times [y_2, x_2)\) ã®ç·å’Œã‚’è¿”ã™ã€‚</li>
</ul>
</li>
<li><code>print(prints_prev)</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚</li>
</ul>
<h2 id="refs-13"><a class="header" href="#refs-13">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/luzhiled/snippets/dp/slide-min.html">https://ei1333.github.io/luzhiled/snippets/dp/slide-min.html</a>, ei1333</li>
</ul>
<h2 id="impl-14"><a class="header" href="#impl-14">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T, bool is_rect_addition&gt;
struct CumulativeSum2d {
   private:
    int _h, _w;
    vector&lt;vector&lt;T&gt;&gt; v;
    bool built = false;

   public:
    CumulativeSum2d(int h, int w) : _h(h + 1), _w(w + 1) { init(); }
    void init() { v = vector(_h, vector&lt;T&gt;(_w)); }
    void add(int y1, int x1, int y2, int x2, T a) {
        assert(is_rect_addition &amp;&amp; !built &amp;&amp; 0 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt; _h &amp;&amp; 0 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt; _w);
        y1++, x1++, y2++, x2++;
        v[y1][x1] += a, v[y1][x2] -= a, v[y2][x1] -= a, v[y2][x2] += a;
    }
    T get(int y, int x) {
        assert(is_rect_addition &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; _w);
        build();
        return v[y + 1][x + 1];
    }
    void add(int y, int x, T a) {
        assert(!is_rect_addition &amp;&amp; !built &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; _w);
        v[y + 1][x + 1] += a;
    }
    T get(int y1, int x1, int y2, int x2) {
        assert(!is_rect_addition &amp;&amp; 0 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt; _h &amp;&amp; 0 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt; _w);
        build();
        return v[y2][x2] - v[y1][x2] - v[y2][x1] + v[y1][x1];
    }
#ifdef _DEBUG
    void print(bool prints_prev = true) {
        auto _print = [&amp;]() {
            for (int i = 1; i &lt; _h; i++) {
                for (int j = 1; j &lt; _w; j++) {
                    if (j &gt; 1) cout &lt;&lt; ' ';
                    cout &lt;&lt; v[i][j];
                }
                cout &lt;&lt; '\n';
            }
            cout &lt;&lt; '\n';
        };
        if (!built &amp;&amp; prints_prev) _print();
        build();
        _print();
    }
#else
    void print(bool = true) {}
#endif

   private:
    void build() {
        if (built) return;
        built = true;
        for (int i = 1; i &lt; _h; i++) {
            for (int j = 1; j &lt; _w; j++) v[i][j] += v[i - 1][j];
        }
        for (int i = 1; i &lt; _h; i++) {
            for (int j = 1; j &lt; _w; j++) v[i][j] += v[i][j - 1];
        }
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swag-sliding-window-aggregation"><a class="header" href="#swag-sliding-window-aggregation">SWAG (Sliding Window Aggregation)</a></h1>
<p>åŠç¾¤ã®å…ƒã‹ã‚‰ãªã‚‹åˆ— \(\boldsymbol a = a_0, a_1, \cdots, a_{n-1}\) ã‚’æ‰±ã†ã€‚Sparse Table ã¯ SWAG ã§ç½®ãæ›ãˆã‚‰ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚</p>
<ul>
<li>constructor <code>SWAG&lt;T&gt;(op, id)</code>: å‹ \(T\)ã€æ¼”ç®— \(op\)ã€å˜ä½å…ƒ \(id\) ã§åˆæœŸåŒ–ã€‚ \(\Theta(1)\)</li>
<li><code>push(x)</code>: \(\boldsymbol a\) ã®æœ«å°¾ã«è¦ç´  \(x\) ã‚’è¿½åŠ ã™ã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>pop()</code>: \(\boldsymbol a\) ã®å…ˆé ­ã«ã‚ã‚‹è¦ç´  \(a_0\) ã‚’å‰Šé™¤ã™ã‚‹ã€‚<code>fold()</code> ã‚’è¿”ã™ã€‚ \(\Theta(1)\)</li>
<li><code>fold()</code>: \(\boldsymbol a\) ã®è¦ç´ ã®ç·ç© \(a_0 \cdot a_1 \cdot \: \cdots \: \cdot a_{n-1}\) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(\Theta(1)\)</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-cpp">#include &quot;data-structures/swag.hpp&quot;
using ll = long long;
ll op(ll x, ll y) { return max(x, y); };
int main() {
    const ll id = -1e18;
    using SW = SWAG&lt;ll, op, id&gt;;
    SW sw;
}
</code></pre>
<h2 id="refs-14"><a class="header" href="#refs-14">Refs</a></h2>
<ul>
<li><a href="https://github.com/tatyam-prime/kyopro_library/blob/master/SWAG.cpp">https://github.com/tatyam-prime/kyopro_library/blob/master/SWAG.cpp</a>, tatyam</li>
<li><a href="https://motsu-xe.hatenablog.com/entry/2021/05/13/224016">SWAG(Sliding Window Aggregation)å†è€ƒ</a>, Motsu_xe</li>
</ul>
<h2 id="impl-15"><a class="header" href="#impl-15">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T, T (*op)(T, T), T id&gt;
struct SWAG {
   private:
    int sz = 0;
    vector&lt;T&gt; fold_l, r;
    T fold_r = id;

   public:
    SWAG() { assert(op(id, id) == id); }
    void push(T x) {
        fold_r = op(fold_r, x);
        r.push_back(x);
        sz++;
    }
    T pop() {
        assert(sz &gt; 0);
        T res = fold();
        if (fold_l.empty()) {
            for (int i = sz - 1; i &gt;= 0; i--) fold_l.push_back(r[i]);
            r.clear();
            fold_r = id;
            for (int i = 1; i &lt; sz; i++) fold_l[i] = op(fold_l[i], fold_l[i - 1]);
        }
        fold_l.pop_back();
        sz--;
        return res;
    }
    T fold() {
        return fold_l.empty() ? fold_r : op(fold_l.back(), fold_r);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree-é…å»¶è©•ä¾¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨"><a class="header" href="#segment-tree-é…å»¶è©•ä¾¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨">Segment Tree (é…å»¶è©•ä¾¡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæœ¨)</a></h1>
<ul>
<li>constructor <code>SegmentTree&lt;V, T&gt;(vals, _ev, _fv, _et, _ft, _fm)</code>: <code>init(vals)</code> ã‚’å‘¼ã¶ã€‚</li>
<li><code>init(vals)</code>: åˆæœŸåŒ–ã€‚</li>
<li><code>apply(t, l, r = -1)</code>: \([l,r)\) ã« <code>t</code> ã‚’ä½œç”¨ã™ã‚‹ã€‚</li>
<li><code>leftmost(l, f)</code>: \(val[l:]\) ã«ãŠã„ã¦å¢ƒç•Œã®æœ€å·¦ä½ç½®ã€‚</li>
<li><code>rightmost(r, f)</code>: \(val[:r]\) ã«ãŠã„ã¦å¢ƒç•Œã®æœ€å³ä½ç½®ã€‚</li>
<li><code>prod(l, r)</code>: \(f[l,r)\) ã‚’è¿”ã™ã€‚</li>
</ul>
<h2 id="refs-15"><a class="header" href="#refs-15">Refs</a></h2>
<ul>
<li><a href="https://betrue12.hateblo.jp/entry/2020/09/23/005940">AtCoder Libraryã®Lazy Segtreeã®ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆ</a>, betrue12</li>
<li><a href="https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp">https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp</a>, yosupo</li>
</ul>
<h2 id="impl-16"><a class="header" href="#impl-16">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class V, class T&gt;
struct SegmentTree {
   private:
    int n0, n, logn;
    vector&lt;V&gt; _vals;
    V _ev;
    using FV = function&lt;V(V &amp;, V &amp;)&gt;;
    FV &amp;_fv;
    vector&lt;T&gt; tag;
    T _et;
    using FT = function&lt;T(T &amp;, T &amp;)&gt;;
    FT &amp;_ft;
    using FM = function&lt;V(T &amp;, V &amp;)&gt;;
    FM &amp;_fm;

   public:
    SegmentTree(vector&lt;V&gt; &amp;vals, V &amp;ev, FV fv, T &amp;et, FT ft, FM fm)
        : n0(vals.size()), _ev(ev), _fv(fv), _et(et), _ft(ft), _fm(fm) {
        logn = 31 - __builtin_clz(2 * n0 - 1);
        n = 1 &lt;&lt; logn;
        init(vals);
    }
    void init(vector&lt;V&gt; &amp;vals) {
        assert(n0 == (int)vals.size());
        _vals = vector&lt;V&gt;(n * 2, _ev), tag = vector&lt;T&gt;(n, _et);
        copy(vals.begin(), vals.end(), _vals.begin() + n);
        for (int k = n - 1; k &gt; 0; k--) fv_val(k);
    }
    void apply(T t, int l, int r = -1) {
        if (r == -1) {
            assert(0 &lt;= l &amp;&amp; l &lt; n0);
            eval(l += n);
            add_tag(l, t);
            for (int k = 1; k &lt;= logn; k++) fv_val(l &gt;&gt; k);
            return;
        }
        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= n0);
        if (l == r) return;
        eval(l += n, r += n);
        for (int L = l, R = r; L &lt; R; L &gt;&gt;= 1, R &gt;&gt;= 1) {
            if (L &amp; 1) add_tag(L++, t);
            if (R &amp; 1) add_tag(--R, t);
        }
        for (int k = 1; k &lt;= logn; k++) {
            if ((l &gt;&gt; k &lt;&lt; k) != l) fv_val(l &gt;&gt; k);
            if ((r &gt;&gt; k &lt;&lt; k) != r) fv_val((r - 1) &gt;&gt; k);
        }
    }
    template &lt;class F&gt;
    int leftmost(int l, F &amp;f) {
        assert(0 &lt;= l &amp;&amp; l &lt;= n0);
        if (l == n0) return n0 + 1;
        l += n;
        eval(l);
        V cur = _ev;
        do {
            l &gt;&gt;= __builtin_ctz(l);
            if (f(_fv(cur, _vals[l]))) {
                while (l &lt; n) {
                    push_tag(l);
                    l &lt;&lt;= 1;
                    if (V tmp = _fv(cur, _vals[l]); !f(tmp)) cur = tmp, l++;
                }
                return l - n + 1;
            }
            cur = _fv(cur, _vals[l++]);
        } while ((l &amp; -l) != l);
        return n0 + 1;
    }
    template &lt;class F&gt;
    int rightmost(int r, F &amp;f) {
        assert(0 &lt;= r &amp;&amp; r &lt;= n0);
        if (r == 0) return -1;
        r += n;
        eval(r - 1);
        V cur = _ev;
        do {
            r &gt;&gt;= __builtin_ctz(r);
            if (r) r--;
            if (f(_fv(_vals[r], cur))) {
                while (r &lt; n) {
                    push_tag(r);
                    r = r * 2 + 1;
                    if (V tmp = _fv(_vals[r], cur); !f(tmp)) cur = tmp, r--;
                }
                return r - n;
            }
            cur = _fv(_vals[r], cur);
        } while ((r &amp; -r) != r);
        return -1;
    }
    V prod(int l, int r) {
        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= n0);
        if (l == r) return _ev;
        eval(l += n, r += n);
        V L = _ev, R = _ev;
        for (; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
            if (l &amp; 1) L = _fv(L, _vals[l++]);
            if (r &amp; 1) R = _fv(_vals[--r], R);
        }
        return _fv(L, R);
    }
    V operator[](int i) {
        assert(0 &lt;= i &amp;&amp; i &lt;= n0);
        eval(i += n);
        return _vals[i];
    }
    void print() {
        cout &lt;&lt; &quot;seg: [&quot;;
        for (int i = 0; i &lt; n0; i++) {
            if (i) cout &lt;&lt; &quot;, &quot;;
            cout &lt;&lt; (*this)[i];
        }
        cout &lt;&lt; &quot;]\n&quot;;
    }

   private:
    void fv_val(int k) { _vals[k] = _fv(_vals[k &lt;&lt; 1], _vals[k &lt;&lt; 1 | 1]); }
    void add_tag(int i2, T &amp;tag1) {
        _vals[i2] = _fm(tag1, _vals[i2]);
        if (i2 &lt; n) tag[i2] = _ft(tag1, tag[i2]);
    }
    void push_tag(int i1) {
        add_tag(i1 &lt;&lt; 1, tag[i1]);
        add_tag(i1 &lt;&lt; 1 | 1, tag[i1]);
        tag[i1] = _et;
    }
    void eval(int i) {
        for (int k = logn; k &gt;= 1; k--) push_tag(i &gt;&gt; k);
    }
    void eval(int l, int r) {
        for (int k = logn; k &gt;= 1; k--) {
            if ((l &gt;&gt; k &lt;&lt; k) != l) push_tag(l &gt;&gt; k);
            if ((r &gt;&gt; k &lt;&lt; k) != r) push_tag((r - 1) &gt;&gt; k);
        }
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slope-trick"><a class="header" href="#slope-trick">Slope Trick</a></h1>
<p>ã©ã®å‚¾ãã‚‚æ•´æ•°ã§ã‚ã‚‹åŒºåˆ†ç·šå½¢å‡¸é–¢æ•° \(f(x)\) ã‚’åŠ¹ç‡çš„ã«æ‰±ã†ã€‚ä»¥ä¸‹ \(n = (é–¢æ•° f ã®å‚¾ãã®å¤‰åŒ–ç‚¹ã®å€‹æ•°)\) ã¨ã™ã‚‹ã€‚</p>
<ol>
<li>å†…éƒ¨å®Ÿè£…ã«ã¤ã„ã¦ã€‚</li>
</ol>
<ul>
<li><code>priority_queue&lt;T&gt; ql;</code>: <code>x &lt; get_min_x()</code> ãªã‚‹ \(x\) ã® maxã€‚</li>
<li><code>priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; qr;</code>: <code>x &gt; get_min_x()</code> ãªã‚‹ \(x\) ã® minã€‚</li>
</ul>
<ol start="2">
<li>public ãª constructorãƒ»é–¢æ•°ã«ã¤ã„ã¦ã€‚</li>
</ol>
<ul>
<li>constructor <code>SlopeTrick&lt;T&gt;()</code></li>
<li><code>clear_l()</code>: <code>ql</code> ã‚’å…¨å‰Šé™¤ã€‚å³å´ç´¯ç© min ã‚’ã™ã‚‹ã€‚</li>
<li><code>clear_r()</code>: <code>qr</code> ã‚’å…¨å‰Šé™¤ã€‚å·¦å´ç´¯ç© min ã‚’ã™ã‚‹ã€‚</li>
<li><code>add_a_minus_x(a)</code>: \(f(x) += a-x\) ã¨ã™ã‚‹ã€‚</li>
<li><code>add_x_minus_a(a)</code>: \(f(x) += x-a\) ã¨ã™ã‚‹ã€‚</li>
<li><code>add_ab_x_minus_a(a)</code>: \(f(x) += |x-a|\) ã¨ã™ã‚‹ã€‚</li>
<li><code>shift_x(x)</code>: \(x += a\) (i.e. \(f(x) \to f(x - a)\) ) ã¨ã™ã‚‹ã€‚</li>
<li><code>shift_y(y)</code>: \(f(x) += a\) ã¨ã™ã‚‹ã€‚</li>
<li><code>shift_l(l)</code>: ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤é–¢æ•°ã€‚å·¦å´ã®ã¿ <code>shift_x(l)</code> ã™ã‚‹ã€‚</li>
<li><code>shift_r(r)</code>: ã‚¹ãƒ©ã‚¤ãƒ‰æœ€å°å€¤é–¢æ•°ã€‚å³å´ã®ã¿ <code>shift_x(r)</code> ã™ã‚‹ã€‚</li>
<li><code>get_min_y()</code>: \(min(f(x))\) ã‚’è¿”ã™ã€‚</li>
<li><code>get_min_x()</code>: \(f(x)\) ãŒæœ€å°å€¤ã‚’å–ã‚‹ã‚ˆã†ãª \(x\) ã‚’è¿”ã™ã€‚</li>
<li><code>get_fx(x)</code>: \(f(x)\) ã‚’è¿”ã™ã€‚å‰¯ä½œç”¨: <code>ql</code>ã€<code>qr</code> ã‚’ç ´å£Šã™ã‚‹ã€‚</li>
<li><code>merge(st)</code>: å‰¯ä½œç”¨: <code>st</code> ã‚’ç ´å£Šã™ã‚‹ã€‚</li>
</ul>
<h2 id="refs-16"><a class="header" href="#refs-16">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/structure/others/slope-trick.cpp">https://ei1333.github.io/library/structure/others/slope-trick.cpp</a>, ei1333</li>
<li><a href="https://maspypy.com/slope-trick-1-%E8%A7%A3%E8%AA%AC%E7%B7%A8">slope trick (1) è§£èª¬ç·¨</a>, maspy</li>
</ul>
<h2 id="impl-17"><a class="header" href="#impl-17">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct SlopeTrick {
   public:
    static constexpr T TINF = numeric_limits&lt;T&gt;::max() / 3;

   private:
    T min_y = 0, add_l = 0, add_r = 0;
    priority_queue&lt;T&gt; ql;
    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt; qr;

   public:
    void clear_l() {
        while (!ql.empty()) ql.pop();
    }
    void clear_r() {
        while (!qr.empty()) qr.pop();
    }
    void add_a_minus_x(T a) {
        min_y += max&lt;T&gt;(0, a - top_r());
        push_r(a);
        push_l(pop_r());
    }
    void add_x_minus_a(T a) {
        min_y += max&lt;T&gt;(0, top_l() - a);
        push_l(a);
        push_r(pop_l());
    }
    void add_abs_x_minus_a(T a) {
        add_a_minus_x(a);
        add_x_minus_a(a);
    }
    void shift_x(T x) { add_l += x, add_r += x; }
    void shift_y(T y) { min_y += y; }
    void shift_l(T l) { add_l += l; }
    void shift_r(T r) { add_r += r; }
    T get_min_y() { return min_y; }
    T get_min_x() { return ql.empty() ? qr.empty() ? 0 : top_r() : top_l(); }
    T get_fx(T x) {
        T res = min_y;
        while (!ql.empty()) res += max&lt;T&gt;(0, pop_l() - x);
        while (!qr.empty()) res += max&lt;T&gt;(0, x - pop_r());
        return res;
    }
    void merge(SlopeTrick &amp;st) {
        if (st.size() &gt; size()) {
            swap(st.min_y, min_y);
            swap(st.add_l, add_l);
            swap(st.add_r, add_r);
            swap(st.ql, ql);
            swap(st.qr, qr);
        }
        while (!st.qr.empty()) add_x_minus_a(st.pop_r());
        while (!st.ql.empty()) add_a_minus_x(st.pop_l());
        min_y += st.min_y;
    }
    int size() { return ql.size() + qr.size(); }

   private:
    void push_l(T a) { ql.push(a - add_l); }
    T top_l() { return ql.empty() ? -TINF : ql.top() + add_l; }
    T pop_l() {
        T top = top_l();
        if (!ql.empty()) ql.pop();
        return top;
    }
    void push_r(T a) { qr.push(a - add_r); }
    T top_r() { return qr.empty() ? TINF : qr.top() + add_r; }
    T pop_r() {
        T top = top_r();
        if (!qr.empty()) qr.pop();
        return top;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-table"><a class="header" href="#sparse-table">Sparse Table</a></h1>
<p>æ›´æ–°ãŒãªã„å ´åˆã«ä½¿ãˆã‚‹ã€‚åŒºé–“ã®æœ€å¤§å€¤ãƒ»æœ€å°å€¤ã‚’æ±‚ã‚ã‚‹ã€‚æ¼”ç®—ã¯ minã€max ã®ä»–ã« gcdã€lcm ã‚‚ä½¿ãˆã‚‹ã€‚ãªãŠã€å…¨ã¦ã®ã‚¯ã‚¨ãƒªã«ã¤ã„ã¦ ã€Œ<code>l</code>ã€<code>r</code> ã®å°‘ãªãã¨ã‚‚ä¸€æ–¹ãŒåŒºé–“ã®ç«¯ã€ã®ã¨ãã¯, å·¦å³ã‹ã‚‰ã®ç´¯ç© minã€maxã€gcd ã‹ lcm ã®æ–¹ãŒé«˜é€Ÿ (\(\Theta(n)\))ã€‚</p>
<ul>
<li>constructor <code>SparseTable(v, f)</code>: é…åˆ— <code>v</code>, æ¼”ç®—é–¢æ•° \(f\) ã‚’ç”¨ã„ã¦åˆæœŸåŒ–ã€‚ãªãŠ \(v[i][j] := (åŒºé–“ [j,j+2^i) ã«æ¼”ç®— f ã‚’é©ç”¨ã—ãŸçµæœ)\) ã§ã™ã€‚ \(\Theta(n \log n)\)</li>
<li><code>get(l, r)</code>: åŒºé–“ \([l, r)\) ã«å¯¾ã—æ¼”ç®— \(f\) ã‚’é©ç”¨ã—ãŸçµæœã‚’è¿”ã™ã€‚æ©Ÿæ§‹ã¨ã—ã¦ã¯ \(f[l,r) = f{ f[l,l+i), f[r-i,r) }\) ã§ã™ã€‚ \(\Theta(1)\)</li>
<li><code>print()</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ \(\Theta(n \log n)\)</li>
</ul>
<h2 id="refs-17"><a class="header" href="#refs-17">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/structure/others/sparse-table.cpp">https://ei1333.github.io/library/structure/others/sparse-table.cpp</a>, ei1333</li>
<li><a href="https://ikatakos.com/pot/programming_algorithm/data_structure/sparse_table">Sparse Table ã„ã‹ãŸã“ã®ãŸã“ã¤ã¼</a>, ikatakos</li>
</ul>
<h2 id="impl-18"><a class="header" href="#impl-18">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct SparseTable {
    int n, logn;
    vector&lt;vector&lt;T&gt;&gt; _v;
    using F = function&lt;T(T, T)&gt;;
    F _f;
    SparseTable(vector&lt;T&gt; &amp;v, const F &amp;f)
        : n(v.size()), logn(log2(n) + 1), _v(logn), _f(f) {
        _v[0].resize(n);
        for (int j = 0; j &lt; n; j++) _v[0][j] = v[j];
        for (int i = 1; i &lt; logn; i++) {
            int i_max = n + 1 - (1 &lt;&lt; i);
            _v[i].resize(i_max);
            for (int j = 0; j &lt; i_max; j++) {
                _v[i][j] = _f(_v[i - 1][j], _v[i - 1][j + (1 &lt;&lt; (i - 1))]);
            }
        }
    }
    T get(int l, int r) {
        assert(0 &lt;= l &amp;&amp; l &lt; r &amp;&amp; r &lt;= n);
        int i = log2(r - l);
        return _f(_v[i][l], _v[i][r - (1 &lt;&lt; i)]);
    }
    void print() {
#ifdef _DEBUG
        for (int i = 0; i &lt; logn; i++) {
            for (int j = 0; j &lt; (n + 1 - (1 &lt;&lt; i)); j++) {
                string sj = to_string(j);
                if (sj.size() == 1) sj = ' ' + sj;
                cout &lt;&lt; &quot;_v[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; sj &lt;&lt; &quot;] = _f[&quot; &lt;&lt; sj &lt;&lt; &quot;,&quot; &lt;&lt; sj &lt;&lt; &quot; + 1&lt;&lt;&quot; &lt;&lt; i &lt;&lt; &quot;) = &quot; &lt;&lt; _v[i][j] &lt;&lt; '\n';
            }
        }
#endif
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-find"><a class="header" href="#union-find">Union Find</a></h1>
<p>é›†åˆã‚’æ‰±ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€  (ã€ŒUnion Find æœ¨ã€ã¨ã‹ã‹ã‚Œã¦ã„ã‚‹æ–‡çŒ®ã‚‚ã‚ã‚‹ãŒã€Union Find ã¯æœ¨ã§ã¯ãªã„)ã€‚é›†åˆåŒå£«ã®åˆä½µ (<code>merge</code>)ã€ã‚ã‚‹è¦ç´ ãŒã©ã®é›†åˆã«å±ã—ã¦ã„ã‚‹ã‹ (<code>find</code>) ã‚’ãªã‚‰ã— \(O(\alpha(n))\) æ™‚é–“ã§å‡¦ç†ã§ãã‚‹ (\(\alpha\) ã¯ã‚¢ãƒƒã‚«ãƒ¼ãƒãƒ³ã®é€†é–¢æ•°)ã€‚ç„¡å‘ã‚°ãƒ©ãƒ•ä¸Šã® dfs ã®ä»£ç”¨ã¨ã—ã¦ä½¿ãˆã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚</p>
<ul>
<li>constructor <code>UnionFind(n)</code>: é›†åˆã®è¦ç´ æ•°ã®æœ€å¤§ã‚’ <code>n</code> ã¨ã™ã‚‹ã€‚</li>
<li><code>merge(x, y)</code>: è¦ç´  <code>x</code>ã€<code>y</code> ã®å±ã™ã‚‹é›†åˆã‚’åˆä½µã™ã‚‹ã€‚<code>merge</code> ãŒå¿…è¦ã ã£ãŸã‹ã‚’è¿”ã™ã€‚ \(O(n)\)</li>
<li><code>find(x)</code>: è¦ç´  <code>x</code> ãŒå±ã™ã‚‹é›†åˆã®æ ¹ (ä»£è¡¨è¦ç´ ) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>same(x, y)</code>: è¦ç´  <code>x</code>ã€<code>y</code> ãŒåŒã˜é›†åˆã«å±ã™ã‚‹ã‹ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>size(x)</code>: è¦ç´  <code>x</code> ãŒå±ã™ã‚‹é›†åˆã®è¦ç´ æ•°ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>groups()</code>: ã€Œå„é›†åˆã«å«ã¾ã‚Œã‚‹è¦ç´ ã®é…åˆ—ã€ã®é…åˆ—ã‚’è¿”ã™ã€‚ \(O(n)\)</li>
</ul>
<h2 id="refs-18"><a class="header" href="#refs-18">Refs</a></h2>
<ul>
<li><a href="https://pyteyon.hatenablog.com/entry/2019/03/11/200000">ç«¶ãƒ—ãƒ­è¦šæ›¸ï¼šUnion-Find ã¾ã¨ã‚</a>, pyteyon</li>
</ul>
<h2 id="impl-19"><a class="header" href="#impl-19">Impl</a></h2>
<pre><code class="language-cpp">struct UnionFind {
   private:
    int _n;
    vector&lt;int&gt; par;

   public:
    UnionFind(int n) : _n(n), par(_n, -1) {}
    bool merge(int x, int y) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _n);
        x = find(x), y = find(y);
        if (x == y) return false;
        if (par[x] &gt; par[y]) swap(x, y);
        par[x] += par[y], par[y] = x;
        return true;
    }
    int find(int x) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n);
        return par[x] &lt; 0 ? x : par[x] = find(par[x]);
    }
    bool same(int x, int y) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _n);
        return find(x) == find(y);
    }
    int size(int x) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n);
        return -par[find(x)];
    }
    vector&lt;vector&lt;int&gt;&gt; groups() {
        vector&lt;int&gt; _find(_n), _size(_n);
        for (int i = 0; i &lt; _n; i++) _find[i] = find(i), _size[_find[i]]++;
        vector&lt;vector&lt;int&gt;&gt; res(_n);
        for (int i = 0; i &lt; _n; i++) res[i].reserve(_size[i]);
        for (int i = 0; i &lt; _n; i++) res[_find[i]].push_back(i);
        res.erase(remove_if(res.begin(), res.end(), [](vector&lt;int&gt; &amp;v) { return v.empty(); }), res.end());
        return res;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weighted-union-find"><a class="header" href="#weighted-union-find">Weighted Union Find</a></h1>
<p>é›†åˆåŒå£«ã®é‡ã¿ã®å·®åˆ†ã®æƒ…å ±ã‚’æŒã¤ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã€‚é›†åˆåŒå£«ã®åˆä½µ (<code>merge</code>)ã€ã‚ã‚‹è¦ç´ ãŒã©ã®é›†åˆã«å±ã—ã¦ã„ã‚‹ã‹ (<code>find</code>)ã€é›†åˆåŒå£«ã®é‡ã•ã®å·®ã®å–å¾— (<code>diff</code>) ã‚’ãªã‚‰ã— \(O(\alpha(n))\) æ™‚é–“ã§å‡¦ç†ã§ãã‚‹ (\(\alpha\) ã¯ã‚¢ãƒƒã‚«ãƒ¼ãƒãƒ³ã®é€†é–¢æ•°)ã€‚å·®åˆ†åˆ¶ç´„ç³»ã®å•é¡Œ (<a href="https://tjkendev.github.io/procon-library/python/graph/difference-constraints-ushi.html">ç‰›ã‚²ãƒ¼</a>ãªã©) ã«ç”¨ã„ã‚‹ã€‚</p>
<ul>
<li>constructor <code>WeightedUnionFind(n, id)</code>: é›†åˆã®è¦ç´ æ•°ã®æœ€å¤§ã‚’ <code>n</code>ã€åŠ ç®—ã¨æ¸›ç®—ã®å®šç¾©ã•ã‚ŒãŸå‹ (ã‚¢ãƒ¼ãƒ™ãƒ«ç¾¤ã¨ã„ã†) <code>T</code> ã®å˜ä½å…ƒ (å¤§æŠµã¯ <code>0</code>) ã‚’ <code>id</code> ã§åˆæœŸåŒ–ã€‚</li>
<li><code>merge(x, y, w)</code>: è¦ç´  <code>x</code>ã€<code>y</code> ã«å¯¾ã— <code>wts[y] - wts[x] == w</code> ãŒæˆã‚Šç«‹ã¤ã‚ˆã†ã«åˆä½µã™ã‚‹ã€‚<code>merge</code> ãŒå¿…è¦ã ã£ãŸã‹ã‚’è¿”ã™ã€‚ \(O(n)\)</li>
<li><code>find(x)</code>: è¦ç´  <code>x</code> ãŒå±ã™ã‚‹é›†åˆã®æ ¹ (ä»£è¡¨è¦ç´ ) ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>weight(x)</code>: è¦ç´  <code>x</code> ãŒå±ã™ã‚‹é›†åˆã®é‡ã•ã®ç·å’Œ <code>wts[x]</code> ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>diff(x, y)</code>: è¦ç´  <code>x</code>ã€<code>y</code> ãŒå±ã™ã‚‹é›†åˆã®é‡ã•ã®å·® <code>wts[y] - wts[x]</code> ã‚’è¿”ã™ã€‚ç¬¦åˆä»˜ããªã®ã§æ³¨æ„ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>same(x, y)</code>: è¦ç´  <code>x</code>ã€<code>y</code> ãŒåŒã˜é›†åˆã«å±ã™ã‚‹ã‹ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
<li><code>size(x)</code>: è¦ç´  <code>x</code> ãŒå±ã™ã‚‹é›†åˆã®è¦ç´ ã®æ•°ã‚’è¿”ã™ã€‚ãªã‚‰ã— \(O(\alpha(n))\)</li>
</ul>
<h2 id="refs-19"><a class="header" href="#refs-19">Refs</a></h2>
<ul>
<li><a href="https://ei1333.github.io/library/structure/union-find/weighted-union-find.cpp">https://ei1333.github.io/library/structure/union-find/weighted-union-find.cpp</a>, ei1333</li>
<li><a href="https://qiita.com/drken/items/cce6fc5c579051e64fab">é‡ã¿ä»˜ã Union-Find æœ¨ã¨ãã‚ŒãŒä½¿ãˆã‚‹å•é¡Œã®ã¾ã¨ã‚ã€ãŠã‚ˆã³ã€ç‰›ã‚²ãƒ¼ã«ã¤ã„ã¦</a>, drken</li>
</ul>
<h2 id="impl-20"><a class="header" href="#impl-20">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct WeightedUnionFind {
   private:
    int _n;
    vector&lt;int&gt; par;
    vector&lt;T&gt; wts;

   public:
    WeightedUnionFind(int n, T id = 0) : _n(n), par(_n, -1), wts(_n, id) {}
    bool merge(int x, int y, T w) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _n);
        w += weight(x) - weight(y);
        x = find(x), y = find(y);
        if (x == y) return false;
        if (par[x] &gt; par[y]) swap(x, y), w = -w;
        par[x] += par[y], par[y] = x, wts[y] += w;
        return true;
    }
    int find(int x) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n);
        if (par[x] &lt; 0) return x;
        int par_x = find(par[x]);
        wts[x] += wts[par[x]];
        return par[x] = par_x;
    }
    T weight(int x) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n);
        find(x);
        return wts[x];
    }
    T diff(int x, int y) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _n);
        return weight(y) - weight(x);
    }
    bool same(int x, int y) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; _n);
        return find(x) == find(y);
    }
    int size(int x) {
        assert(0 &lt;= x &amp;&amp; x &lt; _n);
        return -par[find(x)];
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zip-åº§åœ§"><a class="header" href="#zip-åº§åœ§">Zip (åº§åœ§)</a></h1>
<ul>
<li>constructor <code>Zip(n)</code>: é…åˆ—ã‚µã‚¤ã‚º <code>n</code> ã§åˆæœŸåŒ–ã€‚ \(\Theta(n \log n)\)</li>
<li><code>operator[]</code>: åº§åœ§å‰ã¯å€¤ã®ä»£å…¥ç”¨ã§ã€åº§åœ§å¾Œã¯å€¤ã®å–å¾—ç”¨ã€‚ \(\Theta(1)\)<br>
e.g. <code>[8, 100, 33, 33, 33, 12, 6, 1211] -&gt; [1, 4, 3, 3, 3, 2, 0, 5]</code></li>
</ul>
<h2 id="refs-20"><a class="header" href="#refs-20">Refs</a></h2>
<ul>
<li><a href="https://drken1215.hatenablog.com/entry/2021/08/09/235400">åº§æ¨™åœ§ç¸® (åº§åœ§)</a>, drken</li>
</ul>
<h2 id="impl-21"><a class="header" href="#impl-21">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Zip : vector&lt;T&gt; {
   public:
    vector&lt;T&gt; uniq;

   private:
    int _n;
    bool built = false;

   public:
    Zip() : _n(0) {}
    Zip(int n) : _n(n) { this-&gt;resize(_n); }
    void build() {
        if (built) return;
        built = true;
        uniq = *this;
        sort(uniq.begin(), uniq.end());
        uniq.erase(unique(uniq.begin(), uniq.end()), uniq.end());
        for (int i = 0; i &lt; _n; i++) {
            (*this)[i] = lower_bound(uniq.begin(), uniq.end(), (*this)[i]) - uniq.begin();
        }
    }
    void push_back(T x) { assert(!built), this-&gt;push_back(x), _n++; }
    int val_to_ind(T x) { return build(), lower_bound(uniq.begin(), uniq.end(), x) - uniq.begin(); }
    int size() { return build(), uniq.size(); }
    void print() {
        build();
        cout &lt;&lt; &quot;z: [&quot;;
        for (int i = 0; i &lt; _n; i++) {
            if (i) cout &lt;&lt; &quot;, &quot;;
            cout &lt;&lt; &quot;(&quot; &lt;&lt; (*this)[i] &lt;&lt; &quot;, &quot; &lt;&lt; uniq[(*this)[i]] &lt;&lt; &quot;)&quot;;
        }
        cout &lt;&lt; &quot;]\n&quot;;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/dp">lib/cpp/dp</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traveling-salesman-problem-å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œ"><a class="header" href="#traveling-salesman-problem-å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œ">Traveling Salesman Problem (å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œ)</a></h1>
<ul>
<li><code>traveling_salesman_problem(dists)</code>: éš£æ¥è¡Œåˆ— <code>dists</code> ã‹ã‚‰å·¡å›ã‚»ãƒ¼ãƒ«ã‚¹ãƒãƒ³å•é¡Œã‚’è§£ãã€‚ã™ãªã‚ã¡ã€é‡ã¿ä»˜ãæœ‰å‘ã‚°ãƒ©ãƒ• <code>dists</code> ã«ãŠã„ã¦ã€ã‚ã‚‹å§‹ç‚¹ã‹ã‚‰å…¨é ‚ç‚¹ã‚’ã¡ã‚‡ã†ã© 1 å›ãšã¤è¨ªå•ã™ã‚‹æœ€å°ã‚³ã‚¹ãƒˆã‚’è¿”ã™ã€‚ \(O(n 2^n)\)</li>
</ul>
<h2 id="refs-21"><a class="header" href="#refs-21">Refs</a></h2>
<ul>
<li><a href="https://qiita.com/drken/items/7c6ff2aa4d8fce1c9361#11-bit-dp">ãƒ“ãƒƒãƒˆæ¼”ç®— (bit æ¼”ç®—) ã®ä½¿ã„æ–¹ã‚’ç·ç‰¹é›†ï¼ ã€œ ãƒã‚¹ã‚¯ãƒ“ãƒƒãƒˆã‹ã‚‰ bit DP ã¾ã§ ã€œ</a>, drken</li>
</ul>
<h2 id="impl-22"><a class="header" href="#impl-22">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
T traveling_salesman_problem(const vector&lt;vector&lt;T&gt;&gt; &amp;dist) {
    constexpr T TINF = numeric_limits&lt;T&gt;::max() / 3;
    int n = dist.size(), all_bit = (1 &lt;&lt; n) - 1;
    assert(1 &lt;= n &amp;&amp; n &lt;= 30);
    vector dp(1 &lt;&lt; n, vector(n, TINF));
    for (int v = 0; v &lt; n; v++) dp[1 &lt;&lt; v][v] = 0;
    auto rec = [&amp;](auto self, int s1, int v1) -&gt; T {
        if (dp[s1][v1] != TINF) return dp[s1][v1];
        int s0 = s1 ^ (1 &lt;&lt; v1);
        for (int v0 = 0; v0 &lt; n; v0++) {
            if (s0 &amp; (1 &lt;&lt; v0) &amp;&amp; dist[v0][v1] &lt; TINF) dp[s1][v1] = min(dp[s1][v1], self(self, s0, v0) + dist[v0][v1]);
        }
        if (dp[s1][v1] &gt; TINF) dp[s1][v1] = TINF;
        return dp[s1][v1];
    };
    T res = TINF;
    for (int v1 = 0; v1 &lt; n; v1++) res = min(res, rec(rec, all_bit, v1));
    return res;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/geo">lib/cpp/geo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec2-å¹¾ä½•"><a class="header" href="#vec2-å¹¾ä½•">Vec2 (å¹¾ä½•)</a></h1>
<p>å¹¾ä½•ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚äº‹å‰ã« <code>using V2 = Vec2&lt;double&gt;;</code> ã‚„ <code>using V2 = Vec2&lt;int&gt;;</code> ã‚’ã—ã¦ä½¿ã£ã¦ãã ã•ã„ã€‚</p>
<ul>
<li><code>manhattan_dis(v1, v2)</code></li>
<li><code>inter_seg_pt(a1, a2, b)</code>:
3 ç‚¹ã®ä½ç½®é–¢ä¿‚ã‚’è¿”ã™é–¢æ•°ã€‚(<code>A</code> \(\neq\) <code>B</code> ã§ã‚ã‚‹ã“ã¨ãŒå¿…è¦)
<ul>
<li><code>AB</code> ã‹ã‚‰è¦‹ã¦ <code>BC</code> ã¯å³ã«æ›²ãŒã‚‹ (ã¤ã¾ã‚Š å³å›ã‚Š): \(-1\)</li>
<li><code>AB</code> ã‹ã‚‰è¦‹ã¦ <code>BC</code> ã¯å·¦ã«æ›²ãŒã‚‹ (ã¤ã¾ã‚Š å·¦å›ã‚Š): \(+1\)</li>
<li><code>CAB</code> ã®é †ç•ªã§ä¸€ç›´ç·šä¸Šã«ä¸¦ã¶: <code>-2</code></li>
<li><code>ABC</code> ã®é †ç•ªã§ä¸€ç›´ç·šä¸Šã«ä¸¦ã¶: <code>+2</code></li>
<li><code>BCA</code> ã®é †ç•ªã§ä¸€ç›´ç·šä¸Šã«ä¸¦ã¶: <code>0</code></li>
</ul>
</li>
<li><code>angle(a, b, c)</code>: è§’ <code>ABC</code> ã‚’è¿”ã™ã€‚</li>
<li><code>angle_type(a, b, c)</code>: è§’ <code>ABC</code> ãŒé‹­è§’ãªã‚‰ \(-1\)ã€ç›´è§’ãªã‚‰ \(0\)ã€éˆè§’ãªã‚‰ \(1\) ã‚’è¿”ã™ã€‚</li>
<li><code>intersect_type(a1, a2, b1, b2)</code>: ä¸¦è¡Œãªã‚‰ \(0\)ã€äº¤ã‚ã£ã¦ã„ã‚Œã° \(1\)ã€ä¸€è‡´ã§ \(2\). <code>A</code>ã€<code>B</code>: ç›´ç·š.</li>
<li><code>is_intersect_seg(a1, a2, b1, b2)</code>: <code>A</code>ã€<code>B</code>: ç·šåˆ†ã€‚</li>
<li><code>is_intersect_seg_ray(a1, a2, b, b_arg)</code>: <code>A</code>: ç·šåˆ†ã€<code>B</code>: åŠç›´ç·š(ray)ã€‚</li>
<li><code>intersection(a1, a2, b1, b2)</code>: äº¤ç‚¹ã®åº§æ¨™ã‚’æ±‚ã‚ã‚‹ã€‚<code>A</code>, <code>B</code>: ç›´ç·šã€‚</li>
<li><code>dis(a, b, p)</code>: ç›´ç·š <code>AB</code> ã¨ç‚¹ <code>P</code> ã®è·é›¢ã€‚</li>
<li><code>area_triangle(a, b)</code>: ä¸‰è§’å½¢ OAB ã®é¢ç©ã‚’æ±‚ã‚ã‚‹ (<code>O</code>: åŸç‚¹)ã€‚æ­£å·: <code>O</code>ã€<code>A</code>ã€<code>B</code> ãŒå·¦å›ã‚Šã€è² å·: <code>O</code>ã€<code>A</code>ã€<code>B</code> ãŒå³å›ã‚Šã€‚</li>
<li><code>area_polygon(p)</code>: æ­£å·: <code>O</code>ã€<code>A</code>ã€<code>B</code>ã€ \(\cdots\) ãŒå·¦å›ã‚Š, è² å·: <code>O</code>ã€<code>A</code>ã€<code>B</code>ã€ \(\cdots\) ãŒå³å›ã‚Šã€‚</li>
<li><code>center_of_grav_polygon(p)</code>: é‡å¿ƒã®åº§æ¨™ã€‚</li>
<li><code>convex_hull</code>: å‡¸åŒ…ã‚’å½¢æˆã™ã‚‹é ‚ç‚¹ã®é…åˆ—ã‚’è¿”ã™ã€‚ã™ãªã‚ã¡ã€å¤–ã‹ã‚‰è¼ªã‚´ãƒ ã‚’ä»˜ã‘ãŸã¨ãã€è¼ªã‚´ãƒ ã¨æ¥ã™ã‚‹é ‚ç‚¹ã®é…åˆ—ã‚’è¿”ã™ã€‚ \(O(n \log n)\)</li>
</ul>
<h2 id="refs-22"><a class="header" href="#refs-22">Refs</a></h2>
<ul>
<li><a href="https://qiita.com/Reputeless/items/96226cfe1282a014b147">Vec2 ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ï¼ˆãƒ¢ãƒ€ãƒ³ãª C++ ã‚¯ãƒ©ã‚¹ãƒ‡ã‚¶ã‚¤ãƒ³ã®ãŸã‚ã®ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ï¼‰</a>, Ryo Suzuki</li>
<li><a href="https://sen-comp.hatenablog.com/entry/2020/03/12/145742">ï¼’ï¼è¨ˆç®—å¹¾ä½•ã®ã‚¤ãƒ³ãƒ•ãƒ©æ•´å‚™ã€€ã€€ã€€ã‚·ãƒªãƒ¼ã‚ºï¼šã€ŒåŸºç¤çš„è¨ˆç®—å¹¾ä½•ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä½œã‚Šæ–¹ã€</a>, Sen</li>
<li><a href="https://www.ioi-jp.org/camp/2017/2017-sp_camp-hide.pdf">ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚¹ãƒˆã«ãŠã‘ã‚‹è¨ˆç®—å¹¾ä½•å…¥é–€</a>, ç§€ éƒæœª</li>
</ul>
<h2 id="impl-23"><a class="header" href="#impl-23">Impl</a></h2>
<pre><code class="language-cpp">constexpr double EPS = 1e-10;
template &lt;class T&gt;
enable_if_t&lt;is_integral_v&lt;T&gt;, int&gt; sgn(T a) { return (a &gt; 0) - (a &lt; 0); }
template &lt;class T&gt;
enable_if_t&lt;is_floating_point_v&lt;T&gt;, int&gt; sgn(T a) { return (a &gt; EPS) - (a &lt; -EPS); }
template &lt;class T&gt;
struct Vec2 {
    T x, y;
    Vec2(){};
    Vec2(T _x, T _y) : x(_x), y(_y) {}
    Vec2 operator+() const { return *this; }
    Vec2 operator-() const { return {-x, -y}; }
    Vec2 operator+(const Vec2 &amp;v) const { return {x + v.x, y + v.y}; }
    Vec2 operator-(const Vec2 &amp;v) const { return {x - v.x, y - v.y}; }
    Vec2 operator*(T s) const { return {x * s, y * s}; }
    Vec2 operator/(T s) const {
        assert(s != 0);
        return {x / s, y / s};
    }
    Vec2 &amp;operator+=(const Vec2 &amp;v) {
        x += v.x, y += v.y;
        return *this;
    }
    Vec2 &amp;operator-=(const Vec2 &amp;v) {
        x -= v.x, y -= v.y;
        return *this;
    }
    Vec2 &amp;operator*=(T s) {
        x *= s, y *= s;
        return *this;
    }
    bool operator==(const Vec2 &amp;v) { return sgn(x - v.x) == 0 &amp;&amp; sgn(y - v.y) == 0; }
    bool operator!=(const Vec2 &amp;v) { return !(*this == v); }
    bool operator&lt;(const Vec2 &amp;v) { return sgn(x - v.x) ? sgn(x - v.x) &lt; 0 : sgn(y - v.y) &lt; 0; }
    double len() const { return sqrt(len_sq()); }
    T len_sq() const { return x * x + y * y; }
    T dot(const Vec2 &amp;v) const { return x * v.x + y * v.y; }
    T cross(const Vec2 &amp;v) const { return x * v.y - y * v.x; }
    Vec2 rotate(double arg) const {
        assert(is_floating_point_v&lt;T&gt;);
        double cs = cos(arg), sn = sin(arg);
        return {x * cs - y * sn, x * sn + y * cs};
    }
    double angle() const { return atan2(y, x); }
    Vec2 normalized() const {
        assert(is_floating_point_v&lt;T&gt;);
        return *this / len();
    }
    Vec2 normal_unitized() const {
        assert(is_floating_point_v&lt;T&gt;);
        return {-normalized().y, normalized().x};
    }
    friend Vec2 operator*(T s, const Vec2 &amp;v) { return {s * v.x, s * v.y}; }
    friend istream &amp;operator&gt;&gt;(istream &amp;is, Vec2 &amp;v) { return is &gt;&gt; v.x &gt;&gt; v.y; }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Vec2 &amp;v) { return os &lt;&lt; v.x &lt;&lt; ' ' &lt;&lt; v.y; }
};
template &lt;class T&gt;
T manhattan_dis(Vec2&lt;T&gt; &amp;v1, Vec2&lt;T&gt; &amp;v2) {
    Vec2&lt;T&gt; diff = v1 - v2;
    return abs(diff.x) + abs(diff.y);
}
template &lt;class T&gt;
int inter_seg_pt(const Vec2&lt;T&gt; &amp;a1, const Vec2&lt;T&gt; &amp;a2, const Vec2&lt;T&gt; &amp;b) {
    int f = sgn((a2 - a1).cross(b - a1));
    if (f) return f;
    if (sgn((a2 - a1).dot(b - a1)) &lt; 0) return -2;
    if (sgn((a1 - a2).dot(b - a2)) &lt; 0) return 2;
    return 0;
}
template &lt;class T&gt;
long double angle(const Vec2&lt;T&gt; &amp;a, const Vec2&lt;T&gt; &amp;b, const Vec2&lt;T&gt; &amp;c) {
    long double ang = (c - b).angle() - (a - b).angle();
    return ang &lt; 0 ? ang + M_PI * 2 : ang;
}
template &lt;class T&gt;
int angle_type(const Vec2&lt;T&gt; &amp;a, const Vec2&lt;T&gt; &amp;b, const Vec2&lt;T&gt; &amp;c) { return -sgn((a - b).dot(c - b)); }
template &lt;class T&gt;
int intersect_type(const Vec2&lt;T&gt; &amp;a1, const Vec2&lt;T&gt; &amp;a2, const Vec2&lt;T&gt; &amp;b1, const Vec2&lt;T&gt; &amp;b2) {
    if ((a2 - a1).cross(b2 - b1) &gt; EPS) return 1;
    return ((a2 - a1).cross(b1 - a1) &gt; EPS) ? 0 : 2;
}
template &lt;class T&gt;
bool is_intersect_seg(const Vec2&lt;T&gt; &amp;a1, const Vec2&lt;T&gt; &amp;a2, const Vec2&lt;T&gt; &amp;b1, const Vec2&lt;T&gt; &amp;b2) {
    return inter_seg_pt(a1, a2, b1) * inter_seg_pt(a1, a2, b2) &lt;= 0 &amp;&amp; inter_seg_pt(b1, b2, a1) * inter_seg_pt(b1, b2, a2) &lt;= 0;
}
template &lt;class T&gt;
bool is_intersect_seg_ray(const Vec2&lt;T&gt; &amp;a1, const Vec2&lt;T&gt; &amp;a2, const Vec2&lt;T&gt; &amp;b, const double b_arg) {
    return angle(a1, b, a2) &gt; b_arg;
}
template &lt;class T&gt;
Vec2&lt;T&gt; intersection(const Vec2&lt;T&gt; &amp;a1, const Vec2&lt;T&gt; &amp;a2, const Vec2&lt;T&gt; &amp;b1, const Vec2&lt;T&gt; &amp;b2) {
    static constexpr Vec2&lt;T&gt; error_val = {-2022, -2022};
    if (intersect_type(a1, a2, b1, b2) != 1) return error_val;
    return a1 + (a2 - a1) * (b1 - a1).cross(b2 - b1) / (a2 - a1).cross(b2 - b1);
}
template &lt;class T&gt;
double dis(const Vec2&lt;T&gt; &amp;a, const Vec2&lt;T&gt; &amp;b, const Vec2&lt;T&gt; &amp;p) {
    return abs((p - a).cross(b - a) / (b - a).len());
}
template &lt;class T&gt;
double area_triangle(const Vec2&lt;T&gt; &amp;a, const Vec2&lt;T&gt; &amp;b) { return a.cross(b) / 2; }
template &lt;class T&gt;
long double area_polygon(const vector&lt;Vec2&lt;T&gt;&gt; &amp;p) {
    long double area = 0;
    int sz = p.size();
    for (int i = 0; i &lt; sz; i++) area += (long double)p[i].cross(p[(i + 1) % sz]) / 2;
    return area;
}
template &lt;class T&gt;
Vec2&lt;T&gt; center_of_grav_polygon(const vector&lt;Vec2&lt;T&gt;&gt; &amp;p) {
    int n = p.size();
    Vec2&lt;T&gt; grav(0, 0);
    for (int i = 0; i &lt; n; i++) {
        int j = (i + 1) % n;
        grav += (p[i] + p[j]) * p[i].cross(p[j]);
    }
    return grav / (area_polygon(p) * 3);
}
template &lt;class T&gt;
vector&lt;Vec2&lt;T&gt;&gt; convex_hull(vector&lt;Vec2&lt;T&gt;&gt; &amp;pts) {
    int n = pts.size();
    sort(pts.begin(), pts.end());
    stack&lt;pair&lt;int, int&gt;&gt; conv_idx;
    conv_idx.emplace(0, 1);
    for (int i = 2; i &lt; n; i++) {
        int i1, i2;
        while (true) {
            i1 = conv_idx.top().first, i2 = conv_idx.top().second;
            if (inter_seg_pt(pts[i1], pts[i2], pts[i]) != 1) break;
            conv_idx.pop();
            if (conv_idx.empty()) {
                i2 = i1;
                break;
            }
        }
        conv_idx.emplace(i2, i);
    }
    for (int i = n - 2; i &gt;= 0; i--) {
        int i1, i2;
        while (true) {
            i1 = conv_idx.top().first, i2 = conv_idx.top().second;
            if (inter_seg_pt(pts[i1], pts[i2], pts[i]) != 1) break;
            conv_idx.pop();
            if (conv_idx.empty()) {
                i2 = i1;
                break;
            }
        }
        conv_idx.emplace(i2, i);
    }
    int i = 0;
    vector&lt;Vec2&lt;T&gt;&gt; conv(conv_idx.size());
    while (conv_idx.size()) {
        conv[i++] = pts[conv_idx.top().first];
        conv_idx.pop();
    }
    return conv;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/graphs">lib/cpp/graphs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bellman-ford"><a class="header" href="#bellman-ford">Bellman Ford</a></h1>
<p>Bellman Ford æ³•ã€‚æœ‰å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€ã‚ã‚‹å§‹ç‚¹ã‹ã‚‰ä»–ã®é ‚ç‚¹ã¸ã®æœ€çŸ­è·é›¢ã®é…åˆ—ã‚’æ±‚ã‚ã‚‹ã€‚è² é–‰è·¯ã‚‚æ¤œå‡ºã§ãã‚‹ã€‚</p>
<ul>
<li>constructor <code>BellmanFord(n, m)</code>: é ‚ç‚¹æ•° <code>n</code>ã€è¾ºæ•° <code>m</code> ã§åˆæœŸåŒ–ã€‚<code>m</code> ã¯ vector ã® reserve ã«ä½¿ã†ã ã‘ãªã®ã§ \(0\) ã§ã‚‚ã‚ˆã„ã€‚\(\Theta(1)\)</li>
<li><code>add_edge(from, to, dist)</code>: é ‚ç‚¹ <code>from</code> ã‹ã‚‰ <code>to</code> ã«è·é›¢ <code>dist</code> ã®æœ‰å‘è¾ºã‚’å¼µã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>dists(s = -1, g = -1)</code>: ä»–ã®é ‚ç‚¹ã¸ã®æœ€çŸ­è·é›¢ã®é…åˆ—ã‚’è¿”ã™ã€‚\(O(nm)\)
<ul>
<li>
<ol>
<li><code>s == -1, g == -1</code> ã®ã¨ã: ãŸã ã—ã€å§‹ç‚¹ã¯ä»»æ„ã¨ã—ã€è² é–‰è·¯ãŒã‚ã‚Œã°ä»£ã‚ã‚Šã«ç©ºã®é…åˆ—ã‚’è¿”ã™ã€‚</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>s != -1, g == -1</code> ã®ã¨ã: ãŸã ã—ã€å§‹ç‚¹ <code>s</code> ã‹ã‚‰åˆ°é”å¯èƒ½ã§ã‚ã‚‹è² é–‰è·¯ãŒã‚ã‚Œã°ã€ä»£ã‚ã‚Šã«ç©ºã®é…åˆ—ã‚’è¿”ã™ã€‚</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>s != -1, g != -1</code> ã®ã¨ã: ãŸã ã—ã€å§‹ç‚¹ <code>s</code> ã‹ã‚‰çµ‚ç‚¹ <code>g</code> ã«è‡³ã‚‹ã¾ã§ã«è² é–‰è·¯ãŒã‚ã‚Œã°ã€ä»£ã‚ã‚Šã«ç©ºã®é…åˆ—ã‚’è¿”ã™ã€‚(<a href="https://atcoder.jp/contests/abc061/tasks/abc061_d">ABC061 D</a> ã«ç‰¹åŒ–ã—ã¦ã„ã¾ã™)<br />
(ä»¥ä¸‹å‚è€ƒ)</li>
</ol>
</li>
<li>
<ol>
<li>
<ol start="2">
<li><code>g == -1</code> ã®ã¨ã: æœ€çŸ­çµŒè·¯ã®é•·ã•ã¯æœ€å¤§ \(n-1\) ãªã®ã§ \(n\) é‡ã®ãƒ«ãƒ¼ãƒ—ã‚’å›ã—ã¦ã„ã‚‹ã€‚</li>
</ol>
</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>s != -1, g != -1</code> ã®ã¨ã: è² é–‰è·¯ã®é•·ã•ã¯æœ€å¤§ \(n\)ã€æœ€çŸ­çµŒè·¯ã®é•·ã•ã¯æœ€å¤§ \(n-1\) ãªã®ã§ã€è¨ˆ \(2 n-1\) é‡ã®ãƒ«ãƒ¼ãƒ—ã‚’å›ã™å¿…è¦ãŒã‚ã‚‹ã€‚(Refs ã«è¼‰ã›ãŸ editorial.pdf ã‚‚å‚ç…§ã—ã¦ãã ã•ã„)</li>
</ol>
</li>
</ul>
</li>
<li><code>print()</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ã“ã‚Œã¾ã§ã«å…¥åŠ›ã—ãŸ <code>edges</code> ã‚’ cout ã™ã‚‹ã€‚ \(\Theta(m)\)</li>
</ul>
<h2 id="refs-23"><a class="header" href="#refs-23">Refs</a></h2>
<ul>
<li>[<a href="https://atcoder.jp/contests/abc061/tasks/abc061_d">ABC061 D</a> editorial.pdf](https://img.atcoder.jp/abc061/editorial.pdf#page=3)</li>
<li><a href="https://mhrb-minase.hatenablog.com/entry/2019/08/20/003915">ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³•ã«ã¤ã„ã¦ ï½è² é–‰è·¯ã®æ‰±ã„ï½</a>, mhrb</li>
<li><a href="https://algo-logic.info/bellman-ford/">ãƒ™ãƒ«ãƒãƒ³ãƒ•ã‚©ãƒ¼ãƒ‰æ³•ã«ã‚ˆã‚‹å˜ä¸€å§‹ç‚¹æœ€çŸ­çµŒè·¯ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, 634kami</li>
</ul>
<h2 id="impl-24"><a class="header" href="#impl-24">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct BellmanFord {
   public:
    static constexpr T TINF = numeric_limits&lt;T&gt;::max();

   private:
    struct Edge {
        int from, to;
        T dist;
    };
    int _n;
    vector&lt;Edge&gt; edges;

   public:
    BellmanFord(int n, int m) : _n(n) { edges.reserve(m); }
    void add_edge(int from, int to, T dist) {
        edges.push_back({from, to, dist});
    }
    vector&lt;T&gt; dists(int s = -1, int g = -1) {
        assert(-1 &lt;= s &amp;&amp; s &lt; _n &amp;&amp; -1 &lt;= g &amp;&amp; g &lt; _n);
        vector&lt;T&gt; dists;
        if (s == -1) {
            dists.assign(_n, 0);
        } else {
            dists.assign(_n, TINF);
            dists[s] = 0;
        }
        int g_cnt = 0, lp_lim = g == -1 ? _n : _n * 2 - 1;
        for (int lp = 0; lp &lt; lp_lim; lp++) {
            bool upd = false;
            for (auto &amp;[from, to, dist] : edges) {
                if (dists[from] == TINF) continue;
                if (dists[to] &gt; dists[from] + dist) {
                    dists[to] = dists[from] + dist, upd = true;
                    if (to == g &amp;&amp; ++g_cnt &gt;= 2) return {};
                }
            }
            if (!upd) return dists;
        }
        return g == -1 ? vector&lt;T&gt;{} : dists;
    }
    void print() {
#ifdef _DEBUG
        for (auto &amp;[from, to, dist] : edges) {
            cout &lt;&lt; &quot;from, to, dist: &quot; &lt;&lt; from &lt;&lt; &quot;, &quot; &lt;&lt; to &lt;&lt; &quot;, &quot; &lt;&lt; dist &lt;&lt; '\n';
        }
#endif
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h1>
<p>Dijkstra æ³•ã€‚æ­£ã®è¾ºã®ã¿ã‹ã‚‰ãªã‚‹æœ‰å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€ã‚ã‚‹å§‹ç‚¹ã‹ã‚‰ä»–ã®é ‚ç‚¹ã¸ã®æœ€çŸ­è·é›¢ã®é…åˆ—ã‚’æ±‚ã‚ã‚‹ã€‚</p>
<ul>
<li>constructor <code>Dijkstra(nã€m)</code>: é ‚ç‚¹æ•° <code>n</code>ã€è¾ºæ•° <code>m</code> ã§åˆæœŸåŒ–ã€‚<code>m</code> ã¯ vector ã® reserve ã«ä½¿ã†ã ã‘ãªã®ã§ \(0\) ã§ã‚‚ã‚ˆã„ã€‚ \(\Theta(1)\)</li>
<li><code>add_edge(from, to, cost)</code>: é ‚ç‚¹ <code>from</code> ã‹ã‚‰ <code>to</code> ã«é‡ã¿ <code>cost</code> ã®æœ‰å‘è¾ºã‚’å¼µã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>dists(s = 0)</code>: å§‹ç‚¹ <code>s</code> ã‹ã‚‰ä»–ã®é ‚ç‚¹ã¸ã®æœ€çŸ­è·é›¢ã®é…åˆ—ã‚’è¿”ã™ã€‚ \(O(n \log m)\)</li>
</ul>
<h2 id="impl-25"><a class="header" href="#impl-25">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class Cost&gt;
class Dijkstra {
   private:
    int _n;
    bool _directed;

   public:
    struct Edge {
        int to;
        Cost cost;
    };
    vector&lt;vector&lt;Edge&gt;&gt; edges;
    vector&lt;Cost&gt; _dists;
    const Cost COST_INF = numeric_limits&lt;Cost&gt;::max();
    Dijkstra(int n, bool directed = false) : _n(n), _directed(directed), edges(_n) {}
    void add_edge(int from, int to, Cost cost) {
        edges[from].push_back({to, cost});
        if (!_directed) edges[to].push_back({from, cost});
    }
    vector&lt;Cost&gt; dists(int s = 0) {
        _dists.assign(_n, COST_INF);
        _dists[s] = 0;
        priority_queue&lt;pair&lt;Cost, int&gt;, vector&lt;pair&lt;Cost, int&gt;&gt;, greater&lt;pair&lt;Cost, int&gt;&gt;&gt; q;
        q.emplace(_dists[s], s);
        while (!q.empty()) {
            auto [prev_d, v] = q.top();
            q.pop();
            if (prev_d &gt; _dists[v]) continue;
            for (auto &amp;e : edges[v]) {
                Cost nxt_dis = _dists[v] + e.cost;
                if (_dists[e.to] &gt; nxt_dis) {
                    _dists[e.to] = nxt_dis;
                    q.emplace(_dists[e.to], e.to);
                }
            }
        }
        return _dists;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinic-æœ€å¤§æµ"><a class="header" href="#dinic-æœ€å¤§æµ">Dinic (æœ€å¤§æµ)</a></h1>
<p>Dinic æ³•ã€‚æœ€å¤§æµå•é¡Œã‚’è§£ãã€‚ä»¥ä¸‹ã€ \(m = (è¾ºæ•°)\) ã¨ã™ã‚‹ã€‚</p>
<ul>
<li><code>dinic(n)</code>: é ‚ç‚¹æ•° <code>n</code> ã‚’æŒ‡å®šã€‚ \(\Theta(1)\)</li>
<li><code>add_edge(from, to, cap)</code>: <code>from</code> ã‹ã‚‰ <code>to</code> ã¸æœ€å¤§å®¹é‡ <code>cap</code> ã®è¾ºã‚’è¿½åŠ ã€‚ \(\Theta(1)\)</li>
<li><code>get_edge(i)</code>: i ç•ªç›®ã«è¿½åŠ ã—ãŸè¾ºã‚’è¿”ã™ã€‚ \(\Theta(1)\)</li>
<li><code>get_edges()</code>: å…¨ã¦ã®è¾ºã®é…åˆ—ã‚’è¿”ã™ã€‚ \(\Theta(m)\)</li>
<li><code>for_each_path(f)</code>: ãã‚Œãã‚Œã® path ã«å¯¾ã—é–¢æ•° f ã‚’ä½œç”¨ã™ã‚‹ã€‚ \(\Theta(m)\) (é–¢æ•° <code>f</code> ãŒ \(\Theta(1)\) ã®ã¨ã)</li>
<li><code>change_edge(new_cap, new_flow)</code>: i ç•ªç›®ã«è¿½åŠ ã—ãŸè¾ºã®å®¹é‡, æµé‡ã‚’ <code>new_cap</code>, <code>new_flow</code> ã«å¤‰æ›´ã™ã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>flow(s, t, f_lim)</code>: é ‚ç‚¹ <code>s</code> ã‹ã‚‰ <code>t</code> ã¸æµé‡ãŒ <code>f_lim</code> ä»¥ä¸‹ã®ç¯„å›²ã§ã§ãã‚‹é™ã‚Šæµã—, æµã—ãŸé‡ã‚’è¿”ã™ã€‚ è¨ˆç®—é‡ã¯ \(O(n^2 m)\) ã ãŒ, worst case ã¨ãªã‚‹ã“ã¨ã¯æ®†ã©ãªã„ã€‚</li>
<li><code>min_cut(s)</code>: é ‚ç‚¹ <code>s</code> ã‹ã‚‰ <code>i</code> ã¸ã®æ®‹ä½™ã‚°ãƒ©ãƒ•ã§åˆ°é”å¯èƒ½ã‹ã©ã†ã‹ã®é…åˆ—ã‚’è¿”ã™ã€‚ \(O(n+m)\)</li>
</ul>
<h2 id="refs-24"><a class="header" href="#refs-24">Refs</a></h2>
<ul>
<li><a href="https://github.com/atcoder/ac-library/blob/master/atcoder/maxflow.hpp">https://github.com/atcoder/ac-library/blob/master/atcoder/maxflow.hpp</a>, yosupo</li>
</ul>
<h2 id="impl-26"><a class="header" href="#impl-26">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Dinic {
   private:
    int _n;
    struct _Edge {
        int to, rev_idx;
        T cap;
    };
    vector&lt;pair&lt;int, int&gt;&gt; pos;
    vector&lt;vector&lt;_Edge&gt;&gt; edges;
    static constexpr T TINF = numeric_limits&lt;T&gt;::max();

   public:
    struct Edge {
        int from, to;
        T cap, flow;
    };
    Dinic(int n) : _n(n), edges(_n) {}
    void add_edge(int from, int to, T cap = 1) {
        int from_idx = edges[from].size(), to_idx = edges[to].size();
        pos.emplace_back(from, from_idx);
        if (from == to) to_idx++;
        edges[from].push_back({to, to_idx, cap});
        edges[to].push_back({from, from_idx, 0});
    }
    Edge get_edge(int i) {
        auto &amp;e = edges[pos[i].first][pos[i].second], &amp;re = edges[e.to][e.rev_idx];
        return Edge{pos[i].first, e.to, e.cap + re.cap, re.cap};
    }
    vector&lt;Edge&gt; get_edges() {
        int m = pos.size();
        vector&lt;Edge&gt; res;
        for (int i = 0; i &lt; m; i++) res.push_back(get_edge(i));
        return res;
    }
    void for_each_path(const function&lt;void(int, int, T)&gt; &amp;f) {
        for (auto &amp;[from, rev_idx] : pos) {
            auto &amp;e = edges[from][rev_idx];
            f(from, e.to, edges[e.to][e.rev_idx].cap);
        }
    }
    void change_edge(int i, T new_cap, T new_flow) {
        auto &amp;e = edges[pos[i].first][pos[i].second], &amp;re = edges[e.to][e.rev_idx];
        e.cap = new_cap - new_flow, re.cap = new_flow;
    }
    T flow(int s, int t, T f_lim = -1) {
        if (f_lim == -1) f_lim = TINF;
        vector&lt;int&gt; level(_n), cur_iter(_n);
        auto set_level = [&amp;]() {
            fill(level.begin(), level.end(), -1);
            level[s] = 0;
            queue&lt;int&gt; q;
            q.push(s);
            while (!q.empty()) {
                int from = q.front();
                q.pop();
                for (auto &amp;e : edges[from]) {
                    if (e.cap == 0 || level[e.to] &gt;= 0) continue;
                    level[e.to] = level[from] + 1;
                    if (e.to == t) return;
                    q.push(e.to);
                }
            }
        };
        auto try_to_flow = [&amp;](auto self, int v, T f_in) {
            if (v == s) return f_in;
            T f_out = 0;
            for (int &amp;i = cur_iter[v]; i &lt; (int)edges[v].size(); i++) {
                auto &amp;e = edges[v][i];
                if (level[v] &lt;= level[e.to] || edges[e.to][e.rev_idx].cap == 0) continue;
                T f_part = self(self, e.to, min(f_in - f_out, edges[e.to][e.rev_idx].cap));
                if (f_part &lt;= 0) continue;
                edges[v][i].cap += f_part, edges[e.to][e.rev_idx].cap -= f_part, f_out += f_part;
                if (f_out == f_in) break;
            }
            return f_out;
        };
        T f_res = 0;
        while (f_res &lt; f_lim) {
            set_level();
            if (level[t] == -1) break;
            fill(cur_iter.begin(), cur_iter.end(), 0);
            while (f_res &lt; f_lim) {
                T f_part = try_to_flow(try_to_flow, t, f_lim - f_res);
                if (!f_part) break;
                f_res += f_part;
            }
        }
        return f_res;
    }
    vector&lt;bool&gt; get_min_cut(int s) {
        vector&lt;bool&gt; reachable(_n);
        queue&lt;int&gt; q;
        q.push(s);
        while (!q.empty()) {
            int p = q.front();
            q.pop();
            reachable[p] = true;
            for (auto &amp;e : edges[p]) {
                if (e.cap &amp;&amp; !reachable[e.to]) {
                    reachable[e.to] = true;
                    q.push(e.to);
                }
            }
        }
        return reachable;
    }
    void print() {
#ifdef _DEBUG
        for (auto &amp;[from, rev_idx] : pos) {
            auto &amp;e = edges[from][rev_idx], &amp;rev_e = edges[e.to][e.rev_idx];
            cout &lt;&lt; from &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flowed: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; e.cap + rev_e.cap &lt;&lt; &quot;)\n&quot;;
        }
#endif
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kruskal"><a class="header" href="#kruskal">Kruskal</a></h1>
<p>Kruskal æ³•ã€‚ç„¡å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€å…¨åŸŸã‚’åŒ…å›²ã§ãã‚‹æœ¨ã®æœ€å°ã‚³ã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ã€‚ã“ã®æ™‚ã«ä½œã‚‰ã‚Œã‚‹æœ¨ã‚’æœ€å°å…¨åŸŸæœ¨ã¨ã„ã†ã€‚</p>
<ul>
<li>constructor <code>Kruskal(n, m)</code>: é ‚ç‚¹æ•° <code>n</code>, è¾ºæ•° <code>m</code> ã§åˆæœŸåŒ–ã€‚<code>m</code> ã¯ vector ã® reserve ã«ä½¿ã†ã ã‘ãªã®ã§ <code>0</code> ã§ã‚‚å•é¡Œãªã„ã§ã™ã€‚ \(\Theta(1)\)</li>
<li><code>add_edge(u, v, c)</code>: é ‚ç‚¹ <code>u</code>ã€<code>v</code> ã®é–“ã«ã‚³ã‚¹ãƒˆ <code>c</code> ã®è¾ºã‚’å¼µã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>build(builds_mst)</code>: MST ã®é ‚ç‚¹æ•°ã‚’è¿”ã™ (å…¨åŸŸã‚’åŒ…å›²ã§ããŸã‚‰ <code>n</code> ã«ä¸€è‡´)ã€‚<code>builds_mst</code> ãŒ <code>true</code> ãªã‚‰ MST ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚ \(O(m \log m)\)</li>
</ul>
<h2 id="refs-25"><a class="header" href="#refs-25">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/kruskal-mst/">ã‚¯ãƒ©ã‚¹ã‚«ãƒ«æ³•ã«ã‚ˆã‚‹æœ€å°å…¨åŸŸæœ¨ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, 634kami</li>
</ul>
<h2 id="impl-27"><a class="header" href="#impl-27">Impl</a></h2>
<pre><code class="language-cpp">#include &quot;data-structures/union-find.hpp&quot;
template &lt;class T&gt;
struct Kruskal {
   public:
    struct Edge {
        int u, v;
        T cost;
        bool operator&lt;(const Edge &amp;rhs) { return cost &lt; rhs.cost; }
    };
    vector&lt;Edge&gt; mst;
    T cost_tot = 0;

   private:
    int _n;
    vector&lt;Edge&gt; edges;

   public:
    Kruskal(int n, int m) : _n(n) { edges.reserve(m); }
    void add_edge(int u, int v, T c) { edges.push_back({u, v, c}); }
    int build(bool builds_mst = false) {
        sort(edges.begin(), edges.end());
        UnionFind uf(_n);
        for (auto &amp;e : edges) {
            if (!uf.same(e.u, e.v)) {
                uf.merge(e.u, e.v);
                if (builds_mst) mst.push_back(e);
                cost_tot += e.cost;
            }
        }
        return uf.size(edges[0].u);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prim"><a class="header" href="#prim">Prim</a></h1>
<p>Prim æ³•ã§ã™ãŒéš£æ¥ãƒªã‚¹ãƒˆã§ã¯ãªãéš£æ¥è¡Œåˆ—ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚ç„¡å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã€å…¨åŸŸã‚’åŒ…å›²ã§ãã‚‹æœ¨ã®æœ€å°ã‚³ã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ã€‚ã“ã®æ™‚ã«ä½œã‚‰ã‚Œã‚‹æœ¨ã‚’æœ€å°å…¨åŸŸæœ¨ã¨ã„ã†ã€‚</p>
<ul>
<li>constructor <code>Prim(adja)</code>: é ‚ç‚¹é–“ã«çµã°ã‚Œã‚‹ã‚³ã‚¹ãƒˆã‚’è¡¨ã™éš£æ¥è¡Œåˆ— <code>adja</code> ã‚’å—ã‘å–ã‚Šã€æœ€å°å…¨åŸŸæœ¨ã‚’æ§‹æˆã™ã‚‹è¾ºã®ã‚³ã‚¹ãƒˆã®ç·å’Œã‚’è¿”ã™ã€‚ \(\Theta(n^2)\) (ãŸã ã— \(n = (é ‚ç‚¹æ•°)\))</li>
</ul>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>MST æ§‹ç¯‰ã¯ä½œã£ã¦ã„ã¾ã›ã‚“ã€‚ (Kruskal ã‚’ä½¿ãˆã°ã„ã„ãŸã‚)</p>
<h2 id="refs-26"><a class="header" href="#refs-26">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/prim-mst/">ãƒ—ãƒªãƒ æ³•ã«ã‚ˆã‚‹æœ€å°å…¨åŸŸæœ¨ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, 634kami</li>
</ul>
<h2 id="impl-28"><a class="header" href="#impl-28">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Prim {
    T cost_tot = 0;
    static constexpr T TINF = numeric_limits&lt;T&gt;::max();
    Prim(vector&lt;vector&lt;T&gt;&gt; &amp;adja) {
        int n = adja.size();
        vector&lt;T&gt; min_cost(n, TINF);
        min_cost[0] = 0;
        vector&lt;bool&gt; vis(n);
        while (true) {
            int from = -1;
            for (int u = 0; u &lt; n; u++) {
                if (!vis[u] &amp;&amp; (from == -1 || min_cost[u] &lt; min_cost[from])) from = u;
            }
            if (from == -1) break;
            vis[from] = true;
            cost_tot += min_cost[from];
            for (int to = 0; to &lt; n; to++) {
                if (adja[from][to] != -1) min_cost[to] = min(min_cost[to], adja[from][to]);
            }
        }
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h1>
<p>DAG (directed acyclic graphã€æœ‰å‘éå·¡å›ã‚°ãƒ©ãƒ•) ã®å„ãƒãƒ¼ãƒ‰ã‚’é †åºä»˜ã‘ã—ã¦ã€ã©ã®ãƒãƒ¼ãƒ‰ã‚‚ãã®å‡ºåŠ›è¾ºã®å…ˆã®ãƒãƒ¼ãƒ‰ã‚ˆã‚Šå‰ã«æ¥ã‚‹ã‚ˆã†ã«ä¸¦ã¹ã‚‹ã€‚DAG ã§ã‚ã‚‹ã“ã¨ã¨ topological sort å‡ºæ¥ã‚‹ã“ã¨ã¯åŒå€¤ã€‚é–‰è·¯æ¤œå‡ºæ©Ÿèƒ½ã¯ä½œã£ã¦ã„ã¾ã›ã‚“ã€‚</p>
<ul>
<li><code>topological_sort(edges)</code>: topological sort ã•ã‚ŒãŸé ‚ç‚¹ã®é…åˆ—ã‚’è¿”ã™ã€‚å…¥åŠ›ã•ã‚ŒãŸ <code>edges</code> ãŒ DAG ã§ãªã„ãªã‚‰ç©ºã®é…åˆ—ã‚’è¿”ã™ã€‚ \(O(n+m)\) (ãŸã ã—ã€ \(n = (é ‚ç‚¹æ•°)ã€m = (è¾ºæ•°)\))</li>
</ul>
<h2 id="refs-27"><a class="header" href="#refs-27">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/topological-sort/">ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆé–‰è·¯ã®ãªã„æœ‰å‘ã‚°ãƒ©ãƒ•DAGã®ã‚½ãƒ¼ãƒˆï¼‰</a>, 634kami</li>
</ul>
<h2 id="impl-29"><a class="header" href="#impl-29">Impl</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; topological_sort(vector&lt;vector&lt;int&gt;&gt; &amp;edges) {
    int n = edges.size();
    vector&lt;int&gt; cnt(n);
    for (int v1 = 0; v1 &lt; n; v1++) {
        for (auto &amp;v2 : edges[v1]) cnt[v2]++;
    }
    queue&lt;int&gt; q;
    for (int v = 0; v &lt; n; v++) {
        if (cnt[v] == 0) q.push(v);
    }
    vector&lt;int&gt; sorted;
    sorted.reserve(n);
    while (!q.empty()) {
        int v1 = q.front();
        q.pop();
        sorted.push_back(v1);
        if ((int)sorted.size() == n) return sorted;
        for (auto &amp;v2 : edges[v1]) {
            if (--cnt[v2] == 0) q.push(v2);
        }
    }
    return {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/others">lib/cpp/others</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-iostream"><a class="header" href="#fast-iostream">Fast IOStream</a></h1>
<p>é«˜é€Ÿå…¥å‡ºåŠ›ã—ã¾ã™ã€‚æ•´æ•°å‹ã®ã¿å¯¾å¿œã€‚</p>
<h2 id="impl-30"><a class="header" href="#impl-30">Impl</a></h2>
<pre><code class="language-cpp">struct FastIstream {
    FastIstream() { cin.tie(nullptr), ios::sync_with_stdio(false); }
    void tie(ostream *) {}
    template &lt;class T&gt;
    friend enable_if_t&lt;is_integral_v&lt;T&gt;, FastIstream&gt; &amp;operator&gt;&gt;(FastIstream &amp;os, T &amp;x) {
        bool f = false;
        int c = getchar();
        while (isspace(c)) c = getchar();
        if (c == '-') f = true, c = getchar();
        x = 0;
        for (; isdigit(c); c = getchar()) x = x * 10 + (c - '0');
        if (f) x = -x;
        return os;
    }
    template &lt;class T&gt;
    friend enable_if_t&lt;!is_integral_v&lt;T&gt;, FastIstream&gt; &amp;operator&gt;&gt;(FastIstream &amp;os, T &amp;x) {
        cin &gt;&gt; x;
        return os;
    }
} _cin;
#define cin _cin
struct FastOstream {
    template &lt;class T&gt;
    friend enable_if_t&lt;is_integral_v&lt;T&gt;, FastOstream&gt; &amp;operator&lt;&lt;(FastOstream &amp;os, T x) {
        static char buf[20];
        if (x &lt; 0) putchar('-'), x = -x;
        int len = 0;
        for (; !len || x; x /= 10) buf[len++] = x % 10 + '0';
        while (len) putchar(buf[--len]);
        return os;
    }
    friend FastOstream &amp;operator&lt;&lt;(FastOstream &amp;os, char x) {
        putchar(x);
        return os;
    }
    template &lt;class T&gt;
    friend enable_if_t&lt;!is_integral_v&lt;T&gt;, FastOstream&gt; &amp;operator&lt;&lt;(FastOstream &amp;os, const T &amp;x) {
        cout &lt;&lt; x;
        return os;
    }
} _cout;
#define cout _cout
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-based-data-structures-g-æ‹¡å¼µ"><a class="header" href="#policy-based-data-structures-g-æ‹¡å¼µ">Policy Based Data Structures (g++ æ‹¡å¼µ)</a></h1>
<ul>
<li>ä½¿ã„æ–¹:
<ul>
<li><code>rb_set&lt;T, Comp = less&lt;T&gt;&gt;</code>: <code>std::set</code> ã«å½“ãŸã‚‹ã€‚</li>
<li><code>hash_table&lt;T, U&gt;</code>: <code>std::unordered_map</code> ã«å½“ãŸã‚‹ã€‚</li>
</ul>
</li>
</ul>
<h2 id="refs-28"><a class="header" href="#refs-28">Refs</a></h2>
<ul>
<li><a href="https://xuzijian629.hatenablog.com/entry/2018/12/01/000010">Policy Based Data Structures</a>, xuzijian629</li>
<li><a href="https://codeforces.com/blog/entry/62393">Blowing up unordered_map, and how to stop getting hacked on it</a>, neal</li>
</ul>
<h2 id="impl-31"><a class="header" href="#impl-31">Impl</a></h2>
<pre><code class="language-cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;

using namespace __gnu_pbds;

template &lt;class T, class Comp = less&lt;T&gt;&gt;
using rb_set = tree&lt;T, null_type, Comp, rb_tree_tag, tree_order_statistics_node_update&gt;;

struct custom_hash {
    static ulong splitmix64(ulong x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;
        return x ^ (x &gt;&gt; 31);
    }
    size_t operator()(ulong x) const {
        static const ulong FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
    size_t operator()(pair&lt;int, int&gt; x) const {
        return operator()(ulong(x.first) &lt;&lt; 32 | x.second);
    }
};
template &lt;class T, class U&gt;
using hash_table = gp_hash_table&lt;T, U, custom_hash&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debughpp"><a class="header" href="#debughpp">debug.hpp</a></h1>
<h2 id="impl-32"><a class="header" href="#impl-32">Impl</a></h2>
<pre><code class="language-cpp">#ifndef DEBUG_HPP
#define DEBUG_HPP

#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;atcoder/modint&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

// [isdbg]
#ifdef _DEBUG
const bool isdbg = true;
#else
const bool isdbg = false;
#endif

// [to_string extender]
namespace std {

// std::string, const char*, char
template &lt;class T&gt;
string to_string(T x) {
    stringstream ss;
    ss &lt;&lt; x;
    string res;
    getline(ss, res);
    return &quot;\033[1;33m&quot; + res + &quot;\033[m&quot;;
}

// atcoder::static_modint&lt;m&gt;
template &lt;int m&gt;
string to_string(atcoder::static_modint&lt;m&gt; x) {
    return to_string(x.val());
}

// __int128_t
string to_string(__int128_t x) {
    static const string digs = &quot;0123456789&quot;;
    string s;
    __uint128_t _x = x &lt; 0 ? -x : x;
    do {
        s = digs[_x % 10] + s;
    } while (_x /= 10);
    if (x &lt; 0) s = &quot;-&quot; + s;
    return s;
}

// internal_brackets_parse()
template &lt;class T&gt;
string to_string(vector&lt;T&gt; v) { return internal_brackets_parse(v, &quot;[]&quot;); }
template &lt;class T, ulong n&gt;
string to_string(array&lt;T, n&gt; a) { return internal_brackets_parse(a); }
template &lt;class T&gt;
string to_string(set&lt;T&gt; st) { return internal_brackets_parse(st); }
template &lt;class K, class V&gt;
string to_string(map&lt;K, V&gt; mp) { return internal_brackets_parse(mp); }
template &lt;class K, class V&gt;
string to_string(unordered_map&lt;K, V&gt; mp) { return internal_brackets_parse(mp); }
template &lt;class T&gt;
string to_string(deque&lt;T&gt; q) { return internal_brackets_parse(q); }

template &lt;class A&gt;
string internal_brackets_parse(A v, string brs = &quot;{}&quot;) {
    assert(v.size() &lt; 4096);  // avoid segfault
    string res;
    for (auto x : v) res += to_string(x) + &quot;, &quot;;
    return brs[0] + res.substr(0, res.size() - 2) + brs[1];
}

// std::priority_queue, std::queue, std::stack
template &lt;class T, class Comp&gt;
string to_string(priority_queue&lt;T, vector&lt;T&gt;, Comp&gt; q) {
    string res;
    while (!q.empty()) res = to_string(q.top()) + &quot;, &quot; + res, q.pop();
    return &quot;heapq(&quot; + res.substr(0, res.size() - 2) + &quot;)&quot;;
}
template &lt;class T&gt;
string to_string(queue&lt;T&gt; q) {
    string res;
    while (!q.empty()) res = to_string(q.front()) + &quot;, &quot; + res, q.pop();
    return &quot;queue(&quot; + res.substr(0, res.size() - 2) + &quot;)&quot;;
}
template &lt;class T&gt;
string to_string(stack&lt;T&gt; st) {
    string res;
    while (!st.empty()) res = to_string(st.top()) + &quot;, &quot; + res, st.pop();
    return &quot;stack(&quot; + res.substr(0, res.size() - 2) + &quot;)&quot;;
}

// std::pair
template &lt;class S, class T&gt;
string to_string(pair&lt;S, T&gt; p) {
    return &quot;(&quot; + to_string(p.first) + &quot;, &quot; + to_string(p.second) + &quot;)&quot;;
}

// std::tuple
// Ref: https://theolizer.com/cpp-school2/cpp-school2-20/
template &lt;class Tuple, size_t... I&gt;
string internal_tuple_parse(Tuple t, index_sequence&lt;I...&gt;) {
    string res;
    using swallow = int[];
    (void)swallow{(res += to_string(get&lt;I&gt;(t)) + &quot;, &quot;, 0)...};
    return &quot;(&quot; + res.substr(0, res.size() - 2) + &quot;)&quot;;
}
template &lt;class... Args&gt;
string to_string(tuple&lt;Args...&gt; t) {
    constexpr size_t n = tuple_size&lt;tuple&lt;Args...&gt;&gt;::value;
    return internal_tuple_parse(t, make_index_sequence&lt;n&gt;{});
}

}  // namespace std

template &lt;class T&gt;
std::vector&lt;T&gt; internal_make_v(T *a, int n) {
    std::vector&lt;T&gt; res(n);
    for (int i = 0; i &lt; n; i++) res[i] = a[i];
    return res;
}
#define make_v(a) internal_make_v(a, sizeof(a) / sizeof(a[0]))

template &lt;class T&gt;
std::vector&lt;std::vector&lt;T&gt;&gt; internal_make_vv(T *a, int h, int w) {
    std::vector&lt;std::vector&lt;T&gt;&gt; res(h, std::vector&lt;T&gt;(w));
    for (int i = 0; i &lt; h; i++) {
        for (int j = 0; j &lt; w; j++) res[i][j] = a[i * w + j];
    }
    return res;
}
#define make_vv(a) internal_make_vv(*a, sizeof(a) / sizeof(a[0]), sizeof(a[0]) / sizeof(a[0][0]))

// [dbg]
namespace dbg {

// dout
// Ref: https://ez-net.jp/article/0B/ydQ-Mn1E/uoSm36x6y4XR/
struct DbgOstream {
   private:
    bool is_first_arg;
    int trim_comma_max, trimed_comma_num;

   public:
    DbgOstream() { init(); }

    template &lt;class T&gt;
    friend DbgOstream &amp;operator&lt;&lt;(DbgOstream &amp;os, T x) {
        os.print_info();
        std::cerr &lt;&lt; std::to_string(x);
        return os;
    }
    // dbg::endl
    // Ref: std::basic_ostream
    DbgOstream &amp;operator&lt;&lt;(DbgOstream &amp;(*pf)(DbgOstream &amp;)) {
        return pf(*this);
    }

    void init() {
        is_first_arg = true;
        trim_comma_max = 1;
        trimed_comma_num = 0;
    }

   private:
    void print_info() {
        if (is_first_arg) {
            is_first_arg = false;
        } else {
            if (trimed_comma_num &gt;= trim_comma_max) {
                std::cerr &lt;&lt; &quot;, &quot;;
            } else {
                trimed_comma_num++;
            }
        }
    }
};
// dbg::endl
DbgOstream &amp;endl(DbgOstream &amp;os) {
    std::cerr &lt;&lt; std::endl;
    os.init();
    return os;
}
DbgOstream _dout;

}  // namespace dbg

// dbg::_dout
#ifdef _DEBUG
#define dout std::cerr &lt;&lt; &quot;(\033[1;34m&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;\033[m) &quot;, dbg::_dout
#else
#define dout assert(std::string(__FILE__).find(&quot;.test&quot;) == std::string::npos), \
             std::cerr &lt;&lt; &quot;(\033[1;34m&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;\033[m) &quot;, dbg::_dout
#endif

// [tests]
struct TestsFortmatVerifier {
    TestsFortmatVerifier() {
        assert((std::string(__FILE__).find(&quot;.test&quot;) == std::string::npos) ^
               (std::string(__FILE__).find(&quot;tests/&quot;) != std::string::npos));
    }
} _TestsFortmatVerifier;

// [chrono]
// flag: 0. nano(ns), 1. micro(micros), 2. milli(ms)
// is_acc: 0. 1ms 2ms 3ms 4ms... , 1. 1ms 1ms 1ms 1ms...
void chro(int flag = -1, bool is_acc = true) {
    using namespace std::chrono;
    static int _flag = -1;
    static bool _is_acc = true;  // (_is_acc ? ç´¯ç©å·® : çµŒéæ™‚é–“) ã¨ã—ã¦è¡¨ç¤ºã™ã‚‹
    static system_clock::time_point prev_cnt;

    system_clock::time_point cnt = system_clock::now();
    if (!is_acc) _is_acc = is_acc;
    if (flag != -1) {
        _flag = flag;
    } else {  // 0.nano[ns] 1.micro[micros] 2.milli[ms]
        double time;
        switch (_flag) {
            case 0:
                time = duration_cast&lt;nanoseconds&gt;(cnt - prev_cnt).count();
                dout &lt;&lt; time &lt;&lt; &quot; ns&quot; &lt;&lt; dbg::endl;
                break;
            case 1:
                time = duration_cast&lt;microseconds&gt;(cnt - prev_cnt).count();
                dout &lt;&lt; time &lt;&lt; &quot; mcrs&quot; &lt;&lt; dbg::endl;
                break;
            case 2:
                time = duration_cast&lt;milliseconds&gt;(cnt - prev_cnt).count();
                dout &lt;&lt; time &lt;&lt; &quot; ms&quot; &lt;&lt; dbg::endl;
                break;
        }
    }
    if (flag != -1 || _is_acc) prev_cnt = cnt;
}

#endif  // DEBUG_HPP
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/strings">lib/cpp/strings</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manacher"><a class="header" href="#manacher">Manacher</a></h1>
<p>æœ€é•·å›æ–‡ã€‚snuke ã•ã‚“ã«ã‚ˆã‚Œã°ã€Œã“ã®ã¾ã¾ã§ã¯å¥‡æ•°é•·ã®å›æ–‡ã—ã‹æ¤œå‡ºã§ãã¾ã›ã‚“ãŒã€ã€Œa$b$a$a$bã€ã¿ãŸã„ã«ãƒ€ãƒŸãƒ¼æ–‡å­—ã‚’é–“ã«æŒŸã‚€ã¨å¶æ•°é•·ã®ã‚‚ã®ã‚‚æ¤œå‡ºã§ãã‚‹ã‚ˆã†ã«ã§ãã¾ã™ã€‚ã€ã¨ã®ã“ã¨ã§ã™ã€‚<br />
å®Ÿè£…ã«é–¢ã—ã¦ã¯ã€<code>reused_len</code> \(:= (å†åˆ©ç”¨ã™ã‚‹æ–‡å­—åˆ—é•·) + 1\) ã§ã‚ã‚Šã€<code>r[i-reused_len,i-1] -&gt; r[i+1,i+reused_len]</code> ã®ã‚ˆã†ã«å†åˆ©ç”¨ã—ã¾ã™ã€‚</p>
<ul>
<li><code>manacher(s)</code>: <code>r[i]</code> \(:= (s[i] ã‚’ä¸­å¿ƒã¨ã™ã‚‹æœ€é•·ã®å›æ–‡ã®åŠå¾„)\) ã€‚åŠå¾„ã¨ã„ã†ã®ã¯ã€\(\frac{(å…¨é•·)+1}{2}\) ã®ã“ã¨ã§ã™ã€‚ \(\Theta(n)\) (ãŸã ã— \(n := \left|s\right|\) )</li>
</ul>
<h2 id="refs-29"><a class="header" href="#refs-29">Refs</a></h2>
<ul>
<li><a href="https://snuke.hatenablog.com/entry/2014/12/02/235837">æ–‡å­—åˆ—ã®é ­è‰¯ã„æ„Ÿã˜ã®ç·šå½¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŸã¡ï¼’ - Manacher</a>, snuke</li>
</ul>
<h2 id="impl-33"><a class="header" href="#impl-33">Impl</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; manacher(const string &amp;s) {
    int n = s.size(), i = 0, len = 0;
    vector&lt;int&gt; r(n);
    while (i &lt; n) {
        while (i - len &gt;= 0 &amp;&amp; i + len &lt; n &amp;&amp; s[i - len] == s[i + len]) len++;
        r[i] = len;
        int reused_len = 1;
        while (i - reused_len &gt;= 0 &amp;&amp; reused_len + r[i - reused_len] &lt; len) {
            r[i + reused_len] = r[i - reused_len], reused_len++;
        }
        i += reused_len, len -= reused_len;
    }
    return r;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="morris-pratt-mp-æ³•"><a class="header" href="#morris-pratt-mp-æ³•">Morris Pratt (MP æ³•)</a></h1>
<ul>
<li><code>morris_pratt(s, is_knuth)</code>: \(b[i] := (s[0,i) ã®æœ€é•· border)\) (ãŸã ã— \(b[0] = -1\) )ã€‚border ã¨ã„ã†ã®ã¯ prefix ã‹ã¤ suffix ãªã‚‹æ–‡å­—åˆ—ã®ã“ã¨ã§ã™ã€‚ \(b[n]\) ã ã‘æ±‚ã¾ã‚Œã°ã‚ˆã„å ´åˆã¯ <code>is_knuth</code> ã‚’ <code>true</code> ã«ã—ã¦ã‚ˆãã€å®šæ•°å€é«˜é€Ÿã§ã™ã€‚ \(\Theta(n)\) (ãŸã ã— \(n := |s|\) )<br />
e.g. <code>is_knuth == true</code>: <code>s = &quot;aabaabaaa&quot; -&gt; [-1, 0, 1, 0, 1, 2, 3, 4, 5, 2]</code><br />
<code>is_knuth == false</code>: <code>s = &quot;aabaabaaa&quot; -&gt; [-1, -1, 1, -1, -1, 1, -1, -1, 5, 2]</code></li>
</ul>
<h2 id="refs-30"><a class="header" href="#refs-30">Refs</a></h2>
<ul>
<li><a href="https://snuke.hatenablog.com/entry/2014/12/01/235807">æ–‡å­—åˆ—ã®é ­è‰¯ã„æ„Ÿã˜ã®ç·šå½¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŸã¡ - KMP</a>, snuke</li>
</ul>
<h2 id="impl-34"><a class="header" href="#impl-34">Impl</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; morris_pratt(const string &amp;s, bool is_knuth = false) {
    int n = s.size(), j = -1;
    vector&lt;int&gt; b(n + 1);
    b[0] = -1;
    for (int i = 0; i &lt; n; i++) {
        while (j &gt;= 0 &amp;&amp; s[i] != s[j]) j = b[j];
        b[i + 1] = is_knuth ? (s[i + 1] == s[++j] ? b[j] : j) : ++j;
    }
    return b;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rolling-hash"><a class="header" href="#rolling-hash">Rolling Hash</a></h1>
<p>ãƒ¡ãƒ«ã‚»ãƒ³ãƒŒç´ æ•° \(2^{61}-1\) ã‚’åˆ©ç”¨ã—ãŸ Rolling Hashã€‚</p>
<ul>
<li><code>RollingHash(s, randomizes)</code>: æ–‡å­—åˆ— <code>s</code> ã§åˆæœŸåŒ–ã€‚<code>randomizes</code> ãŒ <code>false</code> ã®ã¨ãã®è¨ˆç®—é‡ã¯ \(\Theta(n)\) ã§ã™ã€‚(ãŸã ã— \(n := \left|s\right|\) )</li>
<li><code>slice(l, r)</code>: <code>s[l:r]</code> ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¿”ã™ã€‚(ãŸã ã—, <code>s[l:r]</code> \(:= (s ã®ã†ã¡åŒºé–“ [l,r) ã®éƒ¨åˆ†)\) .) \(\Theta(1)\)</li>
<li><code>get_lcp(a, b)</code>: <code>s[a:]</code> ã¨ <code>s[b:]</code> ã®ä¸€è‡´æ–‡å­—æ•°ã‚’è¿”ã™ã€‚ \(O(\log n)\)</li>
<li><code>get_lcp(a, rh, b)</code>: <code>s[a:]</code> ã¨ <code>rh.s[b:]</code> ã®ä¸€è‡´æ–‡å­—æ•°ã‚’è¿”ã™ã€‚ \(O(\log (min(n,m)))\) (ãŸã ã— \(m := \left|rh.s\right|\) )</li>
</ul>
<h2 id="refs-31"><a class="header" href="#refs-31">Refs</a></h2>
<ul>
<li><a href="https://qiita.com/keymoon/items/11fac5627672a6d6a9f6">å®‰å…¨ã§çˆ†é€ŸãªRollingHashã®è©±</a>, keymoon</li>
</ul>
<h2 id="impl-35"><a class="header" href="#impl-35">Impl</a></h2>
<pre><code class="language-cpp">using ull = unsigned long long;
struct RollingHash {
   private:
    int n;
    ull base = 127;
    vector&lt;ull&gt; hash, pw;
    static constexpr ull M30 = (1ull &lt;&lt; 30) - 1, M31 = (1ull &lt;&lt; 31) - 1, M61 = (1ull &lt;&lt; 61) - 1;

   public:
    RollingHash() {}
    RollingHash(string &amp;s, bool randomizes = false) : n(s.size()), hash(n + 1), pw(n + 1, 1) {
        if (randomizes) randomize_base();
        for (int i = 0; i &lt; n; i++) {
            hash[i + 1] = mod(mul(hash[i], base) + s[i]), pw[i + 1] = mod(mul(pw[i], base));
        }
    }
    ull slice(int l, int r) {
        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= n);
        return mod(hash[r] + M61 * 4 - mul(hash[l], pw[r - l]));
    }
    int get_lcp(int a, int b) {
        int ok = 0, ng = n - max(a, b);
        while (ng - ok &gt; 1) {
            int mid = (ok + ng) / 2;
            (slice(a, a + mid) == slice(b, b + mid) ? ok : ng) = mid;
        }
        return ok;
    }
    int get_lcp(int a, RollingHash &amp;rh, int b) {
        int ok = 0, ng = min(n - a, rh.n - b);
        while (ng - ok &gt; 1) {
            int mid = (ok + ng) / 2;
            (slice(a, a + mid) == rh.slice(b, b + mid) ? ok : ng) = mid;
        }
        return ok;
    }

   private:
    void randomize_base() {
        random_device rnd;
        int k = int(rnd()) % 2022 + 128;
        base = [&amp;](ull x, int m) {
            ull res = 1;
            while (m) {
                if (m &amp; 1) res = mod(mul(res, x));
                x = mod(mul(x, x)), m /= 2;
            }
            return res;
        }(3, k);
        while (gcd(M61 - 1, k++) &gt; 1) base = mod(mul(base, 3));
    }
    ull mod(ull x) { return x = (x &gt;&gt; 61) + (x &amp; M61), x &gt;= M61 ? x - M61 : x; }
    ull mul(ull a, ull b) {
        ull a0 = a &gt;&gt; 31, a1 = a &amp; M31, b0 = b &gt;&gt; 31, b1 = b &amp; M31, mid = a1 * b0 + a0 * b1;
        return a0 * b0 * 2 + (mid &gt;&gt; 30) + ((mid &amp; M30) &lt;&lt; 31) + a1 * b1;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sa-is-suffix-array"><a class="header" href="#sa-is-suffix-array">SA-IS (Suffix Array)</a></h1>
<p>suffix array ã‚’ \(\Theta(n)\) ã§æ§‹ç¯‰ã™ã‚‹ (ãŸã ã— \(n := \left|s\right|\) )ã€‚</p>
<ul>
<li>constructor <code>SA_IS(s, low_ch = '0', high_ch = 'z')</code>: æ–‡å­—åˆ— <code>s</code> ã«ãŠã„ã¦ ASCII å€¤ã®æœ€å°ã‚’ <code>low_ch</code>, æœ€å¤§ã‚’ <code>high_ch</code> ã§æŒ‡å®šã€‚
\(\Theta(1)\)</li>
<li><code>get_sa()</code>: <code>s</code> ã® suffix array ã‚’è¿”ã™ã€‚ \(\Theta(n)\)</li>
<li><code>contains(t, is_prefix_match)</code>: <code>s</code> ãŒ <code>t</code> ã‚’å«ã‚€ã‹ã©ã†ã‹ã‚’è¿”ã™ã€‚<code>is_prefix_match</code> ãŒ <code>true</code> ãªã‚‰éƒ¨åˆ†ä¸€è‡´ã€<code>false</code> ãªã‚‰å®Œå…¨ä¸€è‡´ã€‚å®Ÿè£…ã¯äºŒåˆ†æ¢ç´¢ã€‚ \(O(\log n)\)</li>
<li><code>print()</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ \(\Theta(n)\)</li>
</ul>
<h2 id="refs-32"><a class="header" href="#refs-32">Refs</a></h2>
<ul>
<li><a href="https://mametter.hatenablog.com/entry/20180130/p1">SA-IS æ³•ã®ãƒ¡ãƒ¢</a>, ku-ma-me</li>
<li><a href="https://github.com/atcoder/ac-library/blob/master/atcoder/string.hpp">https://github.com/atcoder/ac-library/blob/master/atcoder/string.hpp</a>, yosupo</li>
</ul>
<h2 id="impl-36"><a class="header" href="#impl-36">Impl</a></h2>
<pre><code class="language-cpp">struct SA_IS {
   private:
    string _s;
    int _low_ch, _high_ch;
    vector&lt;int&gt; sa, cnt;

   public:
    SA_IS(const string &amp;s, int low_ch = '0', int high_ch = 'z')
        : _s(s), _low_ch(low_ch), _high_ch(high_ch) {}
    vector&lt;int&gt; get_sa() {
        if (sa.size()) return sa;
        int n = _s.size();
        vector&lt;int&gt; vs(n);
        for (int i = 0; i &lt; n; i++) vs[i] = _s[i] - _low_ch;
        return sa_is(vs, _high_ch - _low_ch + 1);
    }
    bool contains(const string &amp;t, bool is_prefix_match = false) {
        if (sa.empty()) get_sa();
        int ng = -1, ok = _s.size();
        while (ok - ng &gt; 1) {
            int mid = (ok + ng) / 2;
            (_s.compare(sa[mid], t.size(), t) &gt;= 0 ? ok : ng) = mid;
        }
        return is_prefix_match ? true : !_s.compare(sa[ok], t.size(), t);
    }
    void print() {
        int n = _s.size(), dig = log10(n) + 1;
        for (int i = 0; i &lt;= n; i++) {
            cout &lt;&lt; &quot;_s[&quot; &lt;&lt; setw(dig) &lt;&lt; sa[i] &lt;&lt; &quot;:] = &quot; &lt;&lt; _s.substr(sa[i]) &lt;&lt; '\n';
        }
    }

   private:
    vector&lt;int&gt; &amp;sa_is(vector&lt;int&gt; s1, int sz) {
        int n = s1.size();
        sa.resize(n + 1);
        if (n == 0) return sa;
        for (auto &amp;c : s1) c++;
        s1.push_back(0);
        sz++;
        vector&lt;bool&gt; iss(n + 1);
        vector&lt;int&gt; bin(sz + 1);
        auto induce = [&amp;](const vector&lt;int&gt; &amp;lms) {
            sa.assign(n + 1, -1);
            cnt.assign(sz, 0);
            for (int i = 0; i &lt; (int)lms.size(); i++) {
                int sx = s1[lms[i]];
                sa[bin[sx + 1] - 1 - cnt[sx]++] = lms[i];
            }
            cnt.assign(sz, 0);
            for (int i = 0; i &lt;= n; i++) {
                int x = sa[i] - 1;
                if (x &gt;= 0 &amp;&amp; !iss[x]) sa[bin[s1[x]] + cnt[s1[x]]++] = x;
            }
            cnt.assign(sz, 0);
            for (int i = n; i &gt;= 0; i--) {
                int x = sa[i] - 1;
                if (x &gt;= 0 &amp;&amp; iss[x]) sa[bin[s1[x] + 1] - 1 - cnt[s1[x]]++] = x;
            }
        };
        vector&lt;int&gt; lms, lms_sz(n + 1, -1);
        iss[n] = 1, bin[1]++;
        for (int i = n - 1; i &gt;= 0; i--) {
            iss[i] = s1[i] == s1[i + 1] ? iss[i + 1] : s1[i] &lt; s1[i + 1];
            if (!iss[i] &amp;&amp; iss[i + 1]) {
                lms_sz[i + 1] = lms.size();
                lms.push_back(i + 1);
            }
            bin[s1[i] + 1]++;
        }
        for (int i = 0; i &lt; sz; i++) bin[i + 1] += bin[i];
        induce(lms);
        if (lms.size() &gt; 1) {
            int m = lms.size(), li = 0;
            vector&lt;int&gt; sorted_lms(m);
            for (auto x : sa) {
                if (lms_sz[x] != -1) sorted_lms[li++] = x;
            }
            int n2 = 1;
            vector&lt;int&gt; s2(m);
            s2[m - 1 - lms_sz[sorted_lms[1]]] = 1;
            for (int i = 2; i &lt; m; i++) {
                int xl = sorted_lms[i], yl = sorted_lms[i - 1];
                int xr = lms[lms_sz[xl] - 1], yr = lms[lms_sz[yl] - 1];
                if (xr - xl != yr - yl) {
                    n2++;
                } else {
                    while (xl &lt;= xr) {
                        if (s1[xl] != s1[yl]) {
                            n2++;
                            break;
                        }
                        xl++, yl++;
                    }
                }
                s2[m - 1 - lms_sz[sorted_lms[i]]] = n2;
            }
            vector&lt;int&gt; lms_sa = sa_is(move(s2), n2 + 1);
            li = m;
            for (int i = 1; i &lt;= m; i++) sorted_lms[--li] = lms[m - 1 - lms_sa[i]];
            induce(sorted_lms);
        }
        return sa;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trie-ãƒˆãƒ©ã‚¤æœ¨"><a class="header" href="#trie-ãƒˆãƒ©ã‚¤æœ¨">Trie (ãƒˆãƒ©ã‚¤æœ¨)</a></h1>
<ul>
<li>constructor <code>Trie&lt;W&gt;()</code>: <code>s_w</code> ã®å‹ã‚’ <code>W</code> ã§åˆæœŸåŒ–. <code>s_w</code> ã‚’ä½¿ã‚ãªã„ãªã‚‰ void ã‚’å…¥ã‚Œã¦ãŠãã€‚ \(\Theta(1)\)</li>
<li><code>insert(s, s_w = -1)</code>: æ–‡å­—åˆ— <code>s</code> ã‚’æŒ¿å…¥ã€‚ \(\Theta(\left|s\right|)\)</li>
<li><code>find(t, f, s_l = 0, t_l = 0)</code>: <code>t_r = t_l, t_l+1, ..., n</code> ã«å¯¾ã—ã€ã€Œã„ãšã‚Œã‹ã® <code>s[s_l:]</code> ã® prefixã€ã¨ã€Œ<code>t[t_l:t_r+1]</code>ã€ã¨ãŒä¸€è‡´ã™ã‚‹ã”ã¨ã«é–¢æ•° <code>f</code> ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚ \(O( \left|t\right| )\)</li>
<li><code>print(cur = 0)</code>: ãƒ‡ãƒãƒƒã‚°ç”¨ã€‚<code>cur</code> ã¯ \(0\) ã®ã¾ã¾ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚ \(O(\sum \left|s\right| )\)</li>
</ul>
<h2 id="refs-33"><a class="header" href="#refs-33">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/trie-tree/">ãƒˆãƒ©ã‚¤æœ¨(Trieæœ¨) ã®è§£èª¬ã¨å®Ÿè£…ã€æ¥é ­è¾(prefix) ã‚’åˆ©ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã€‘</a></li>
<li><a href="https://ei1333.github.io/luzhiled/snippets/structure/trie.html">ãƒˆãƒ©ã‚¤æœ¨(Trie)ï½œLuzhiled's memo</a></li>
</ul>
<h2 id="impl-37"><a class="header" href="#impl-37">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class W&gt;
struct Trie {
   private:
    struct Node {
        char ch;
        W w;
        int nxt, bro;
    };
    vector&lt;Node&gt; nodes;

   public:
    Trie() : nodes(1, {-1, W(), -1, -1}) {}
    void insert(string &amp;s, W s_w) {
        int cur = 0;
        for (char &amp;ch : s) {
            bool upd = false;
            if (nodes[cur].nxt &gt;= 0) {
                for (int b = cur; b &gt;= 0; b = nodes[b].bro) {
                    if (ch == nodes[b].ch) {
                        cur = nodes[b].nxt, upd = true;
                        break;
                    }
                }
            }
            if (upd) continue;
            if (nodes[cur].nxt &gt; 0) {
                nodes.push_back({ch, W(), (int)nodes.size() + 1, nodes[cur].bro});
                nodes[cur].bro = nodes.size() - 1;
            } else {
                nodes[cur].nxt = nodes.size(), nodes[cur].ch = ch;
            }
            cur = nodes.size();
            nodes.push_back({-1, W(), -1, -1});
        }
        nodes[cur].w = s_w;
    }
    void find(string &amp;t, const function&lt;void(int t_r, W w)&gt; &amp;f, int s_l = 0, int t_l = 0) {
        int n = t.size(), cur = s_l;
        assert(s_l &lt; (int)nodes.size() &amp;&amp; t_l &lt; n);
        for (int t_r = t_l; t_r &lt; n; t_r++) {
            bool upd = false;
            if (nodes[cur].nxt &gt;= 0) {
                for (int b = cur; b &gt;= 0; b = nodes[b].bro) {
                    if (t[t_r] == nodes[b].ch) {
                        cur = nodes[b].nxt, upd = true;
                        break;
                    }
                }
            }
            if (!upd) return;
            if (nodes[cur].ch == -1) f(t_r, nodes[cur].w);
        }
    }
#ifdef _DEBUG
    void print(int cur = 0) {
        static string u;
        if (!cur) cout &lt;&lt; &quot;print():\n&quot;, u.clear();
        if (nodes[cur].ch == -1) {
            cout &lt;&lt; setw(4) &lt;&lt; u;
            if (is_arithmetic_v&lt;W&gt;) cout &lt;&lt; setw(4) &lt;&lt; nodes[cur].w;
            cout &lt;&lt; '\n';
        }
        u.push_back(0);
        if (nodes[cur].nxt &gt;= 0) {
            for (int b = cur; b &gt;= 0; b = nodes[b].bro) {
                u.back() = nodes[b].ch;
                print(nodes[b].nxt);
            }
        }
        u.pop_back();
    }
#else
    void print() {}
#endif
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-algorithm-æœ€é•·å…±é€šæ¥é ­è¾"><a class="header" href="#z-algorithm-æœ€é•·å…±é€šæ¥é ­è¾">Z Algorithm (æœ€é•·å…±é€šæ¥é ­è¾)</a></h1>
<ul>
<li><code>z_algorithm(s, x = 0)</code>: æ–‡å­—åˆ— <code>s[x:]</code> ã«å¯¾ã—ã¦æ±‚ã‚ãŸ \(z\) ã‚’è¿”ã™ã€‚å®Ÿè£…ã«é–¢ã—ã¦ã¯ã€<code>reused_len</code> \(:= (å†åˆ©ç”¨ã™ã‚‹æ–‡å­—åˆ—é•·) + 1\) ã§ã‚ã‚Šã€ <code>z[1:reused_len] -&gt; z[i+1:i+reused_len]</code> ã®ã‚ˆã†ã«å†åˆ©ç”¨ã™ã‚‹ã€‚
\(\Theta(n)\) (\(n = \left|s\right|\) ã¨ã—ãŸ)<br />
e.g. <code>s = &quot;ababa&quot; -&gt; [5, 0, 3, 0, 1]</code></li>
<li><code>z_search(s, ptn)</code>: <code>z_idx</code> ã‚’è¿”ã™ã€‚ \(\Theta(n)\)<br />
e.g. <code>s = &quot;ababa&quot;, ptn = &quot;aba&quot; -&gt; [0, 2]</code></li>
</ul>
<h2 id="refs-34"><a class="header" href="#refs-34">Refs</a></h2>
<ul>
<li><a href="https://snuke.hatenablog.com/entry/2014/12/03/214243">æ–‡å­—åˆ—ã®é ­è‰¯ã„æ„Ÿã˜ã®ç·šå½¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŸã¡ï¼“ - Z algorithm</a>, snuke</li>
</ul>
<h2 id="impl-38"><a class="header" href="#impl-38">Impl</a></h2>
<pre><code class="language-cpp">vector&lt;int&gt; z_algorithm(string &amp;s, int x = 0) {
    int n = s.size() - x;
    vector&lt;int&gt; z(n);
    z[0] = n;
    for (int i = 1, len = 0; i &lt; n;) {
        while (i + len &lt; n &amp;&amp; s[x + len] == s[x + i + len]) len++;
        z[i] = len;
        if (len == 0) {
            i++;
            continue;
        }
        int reused_len = 1;
        while (reused_len + z[reused_len] &lt; len) {
            z[i + reused_len] = z[reused_len], reused_len++;
        }
        i += reused_len, len -= reused_len;
    }
    return z;
}
vector&lt;int&gt; z_search(const string &amp;s, const string &amp;ptn) {
    string t = ptn + &quot;$&quot; + s;
    int nt = s.size(), np = ptn.size();
    vector&lt;int&gt; z_idx, z = z_algorithm(t);
    for (int i = np + 1; i &lt; nt + 2; i++) {
        if (z[i] == np) z_idx.push_back(i - np - 1);
    }
    return z_idx;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GitHub: <a href="https://github.com/nullputra/nlptr-lib/tree/master/lib/cpp/trees">lib/cpp/trees</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diameter-æœ¨ã®ç›´å¾„"><a class="header" href="#diameter-æœ¨ã®ç›´å¾„">Diameter (æœ¨ã®ç›´å¾„)</a></h1>
<p>æœ¨ã®ç›´å¾„ã‚’æ±‚ã‚ã‚‹ã€‚</p>
<ul>
<li><code>farthest(edges, v1, v0 = -1)</code>: æœ¨ <code>edges</code> ã«ãŠã„ã¦ã€é ‚ç‚¹ <code>v1</code> ã‹ã‚‰æœ€é ã®é ‚ç‚¹ã‚’è¿”ã™ã€‚ \(\Theta(n)\) (\(n = (é ‚ç‚¹æ•°)\) ã¨ã—ãŸ)</li>
<li><code>diameter(edges)</code>: æœ¨ <code>edges</code> ã®ç›´å¾„ã‚’è¿”ã™ã€‚ \(\Theta(n)\)</li>
</ul>
<h2 id="refs-35"><a class="header" href="#refs-35">Refs</a></h2>
<ul>
<li><a href="https://algo-logic.info/tree-diameter/">æœ¨ã®ç›´å¾„ã‚’æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, 634kami</li>
</ul>
<h2 id="impl-39"><a class="header" href="#impl-39">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct Edge {
    int to;
    T dist;
};
template &lt;class T&gt;
Edge&lt;T&gt; farthest(vector&lt;vector&lt;Edge&lt;T&gt;&gt;&gt; &amp;edges, int v1, int v0 = -1) {
    Edge&lt;T&gt; res{v1, 0};
    for (auto &amp;[v2, dist] : edges[v1]) {
        if (v0 == v2) continue;
        auto nxt = farthest(edges, v2, v1);
        nxt.dist += dist;
        if (res.dist &lt; nxt.dist) res = nxt;
    }
    return res;
}
template &lt;class T&gt;
T diameter(vector&lt;vector&lt;Edge&lt;T&gt;&gt;&gt; &amp;edges) {
    return farthest(edges, farthest(edges, 0).to).dist;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rerootingop_edge-å…¨æ–¹ä½æœ¨-dp"><a class="header" href="#rerootingop_edge-å…¨æ–¹ä½æœ¨-dp">Rerooting[op_edge] (å…¨æ–¹ä½æœ¨ dp)</a></h1>
<p>å…¨æ–¹ä½æœ¨ dp ã®ã†ã¡ã€è¾ºã«å¯¾ã—ã¦ key ã‚’ä¹—ã›ã¦ä½œç”¨ã•ã›ã‚‹ã‚‚ã®ã€‚</p>
<ul>
<li><code>RerootingNode(n, id, merge, op_node)</code>: åˆæœŸåŒ–ã€‚ \(\Theta(1)\)</li>
<li><code>add_edge(u, v, k)</code>: è¾ºã‚’è¿½åŠ ã€‚ \(\Theta(1)\)</li>
<li><code>add_edge(u, v, k1, k2)</code>: è¾ºã‚’è¿½åŠ ã€‚ \(\Theta(1)\)</li>
<li><code>vals()</code>: å…¨æ–¹ä½ dp ã‚’ã—ã¦ <code>_vals</code> ã‚’å–å¾—ã€‚ \(O(\Theta(n))\)</li>
</ul>
<h2 id="refs-36"><a class="header" href="#refs-36">Refs</a></h2>
<ul>
<li><a href="https://ei1333.hateblo.jp/entry/2018/12/21/004022">ã‚‚ã†ã²ã¨ã¤ã®å…¨æ–¹ä½æœ¨DP</a>, ei1333</li>
</ul>
<h2 id="impl-40"><a class="header" href="#impl-40">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class Val, class Key&gt;
struct RerootingEdge {
    struct Edge {
        int to;
        Key key;
        Val val, n_val;
    };
    const Val _id;
    vector&lt;vector&lt;Edge&gt;&gt; edges;
    using F = function&lt;Val(Val, Val)&gt;;
    using G = function&lt;Val(Val, Key)&gt;;
    const F _merge;
    const G _op_edge;
    vector&lt;Val&gt; sub_val, _vals;
    RerootingEdge(int n, Val id, const F &amp;merge, const G &amp;op_edge)
        : _id(id), edges(n), _merge(merge), _op_edge(op_edge), sub_val(n, _id), _vals(n, _id) {}
    void add_edge(int u, int v, Key k) {
        edges[u].push_back({v, k, _id, _id});
        edges[v].push_back({u, k, _id, _id});
    }
    void add_edge_bi(int u, int v, Key k1, Key k2) {
        edges[u].push_back({v, k1, _id, _id});
        edges[v].push_back({u, k2, _id, _id});
    }
    vector&lt;Val&gt; vals() {
        auto dfs_sub = [&amp;](auto self, int idx, int par) -&gt; void {
            for (auto &amp;e : edges[idx]) {
                if (e.to == par) continue;
                self(self, e.to, idx);
                sub_val[idx] = _merge(sub_val[idx], _op_edge(sub_val[e.to], e.key));
            }
        };
        dfs_sub(dfs_sub, 0, -1);
        auto dfs_all = [&amp;](auto self, int idx, int par, Val top) -&gt; void {
            Val buff = _id;
            for (int i = 0; i &lt; (int)edges[idx].size(); i++) {
                auto &amp;e = edges[idx][i];
                e.n_val = buff;
                e.val = _op_edge(par == e.to ? top : sub_val[e.to], e.key);
                buff = _merge(buff, e.val);
            }
            _vals[idx] = buff;
            buff = _id;
            for (int i = edges[idx].size() - 1; i &gt;= 0; i--) {
                auto &amp;e = edges[idx][i];
                if (e.to != par) self(self, e.to, idx, _merge(e.n_val, buff));
                e.n_val = _merge(e.n_val, buff);
                buff = _merge(buff, e.val);
            }
        };
        dfs_all(dfs_all, 0, -1, _id);
        return _vals;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rerootingop_node-å…¨æ–¹ä½æœ¨-dp"><a class="header" href="#rerootingop_node-å…¨æ–¹ä½æœ¨-dp">Rerooting[op_node] (å…¨æ–¹ä½æœ¨ dp)</a></h1>
<p>å…¨æ–¹ä½æœ¨ dp ã®ã†ã¡ã€é ‚ç‚¹ã«å¯¾ã—ã¦ä½œç”¨ã™ã‚‹ã‚‚ã®ã€‚</p>
<ul>
<li><code>RerootingNode(n, id, merge, op_node)</code></li>
<li><code>add_edge(u, v)</code>: è¾ºã‚’è¿½åŠ ã™ã‚‹ã€‚ \(\Theta(1)\)</li>
<li><code>vals()</code>: å…¨æ–¹ä½ dp ã‚’ã—ã¦ <code>_vals</code> ã‚’è¿”ã™ã€‚ \(\Theta(n)\)</li>
</ul>
<h2 id="refs-37"><a class="header" href="#refs-37">Refs</a></h2>
<ul>
<li><a href="https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e">ã€å…¨æ–¹ä½æœ¨DPã€‘æ˜æ—¥ä½¿ãˆã‚‹ä¾¿åˆ©ãªæœ¨æ§‹é€ ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </a>, keymoon</li>
</ul>
<h2 id="impl-41"><a class="header" href="#impl-41">Impl</a></h2>
<pre><code class="language-cpp">template &lt;class T&gt;
struct RerootingNode {
   private:
    struct Edge {
        int to, rev_idx;
        T val;
    };
    int _n, edge_num = 0;
    T _id;
    vector&lt;T&gt; _vals;
    vector&lt;vector&lt;Edge&gt;&gt; edges;
    using FM = function&lt;T(T, T)&gt;;
    const FM _merge;
    using FN = function&lt;T(T, int)&gt;;
    const FN _op_node;

   public:
    RerootingNode(int n, T id, const FM &amp;merge, const FN &amp;op_node)
        : _n(n), _id(id), _vals(_n), edges(_n), _merge(merge), _op_node(op_node) {}
    void add_edge(int u, int v) {
        edge_num++;
        int idx_u = edges[u].size(), idx_v = edges[v].size();
        edges[u].push_back({v, idx_v, _id});
        edges[v].push_back({u, idx_u, _id});
    }
    const vector&lt;T&gt; &amp;vals() {
        assert(edge_num == _n - 1);
        if (_n == 1) return _vals[0] = _op_node(_id, 0), _vals;
        vector&lt;int&gt; par(_n, -1), ordered;
        ordered.reserve(_n);
        auto init_ordered_tree = [&amp;](auto self, int u) -&gt; void {
            ordered.push_back(u);
            for (auto &amp;e : edges[u]) {
                if (e.to == par[u]) continue;
                par[e.to] = u;
                self(self, e.to);
            }
        };
        init_ordered_tree(init_ordered_tree, 0);
        for (int i = _n - 1; i &gt; 0; i--) {
            int u = ordered[i], edge_idx = -1;
            T accum_val = _id;
            for (auto &amp;[to, rev_idx, val] : edges[u]) {
                if (to == par[u]) {
                    edge_idx = rev_idx;
                    continue;
                }
                accum_val = _merge(accum_val, val);
            }
            edges[par[u]][edge_idx].val = _op_node(accum_val, u);
        }
        for (auto &amp;u : ordered) {
            int sz = edges[u].size();
            vector&lt;T&gt; rev_accum(sz, _id);
            T accum_val = _id;
            for (int j = sz - 2; j &gt;= 0; j--) {
                rev_accum[j] = _merge(edges[u][j + 1].val, rev_accum[j + 1]);
            }
            for (int j = 0; j &lt; sz; j++) {
                auto &amp;[to, rev_idx, val] = edges[u][j];
                edges[to][rev_idx].val = _op_node(_merge(accum_val, rev_accum[j]), u);
                accum_val = _merge(accum_val, val);
            }
            _vals[u] = _op_node(accum_val, u);
        }
        return _vals;
    }
    void print() {
        cout &lt;&lt; &quot;edges = {&quot;;
        for (int i = 0; i &lt; _n; i++) {
            if (i) cout &lt;&lt; &quot;, &quot;;
            cout &lt;&lt; '{' &lt;&lt; i &lt;&lt; &quot; -&gt; &quot;;
            for (int j = 0; j &lt; (int)edges[i].size(); j++) {
                if (j) cout &lt;&lt; &quot;, &quot;;
                cout &lt;&lt; edges[i][j].to &lt;&lt; &quot;(val:&quot; &lt;&lt; edges[i][j].val &lt;&lt; &quot;)&quot;;
            }
            cout &lt;&lt; '}';
        }
        cout &lt;&lt; &quot;}\n&quot;;
    }
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
